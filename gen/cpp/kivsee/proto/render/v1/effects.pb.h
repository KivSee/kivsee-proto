// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: kivsee/proto/render/v1/effects.proto
// Protobuf C++ Version: 6.31.0

#ifndef kivsee_2fproto_2frender_2fv1_2feffects_2eproto_2epb_2eh
#define kivsee_2fproto_2frender_2fv1_2feffects_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6031000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "kivsee/proto/render/v1/functions.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_kivsee_2fproto_2frender_2fv1_2feffects_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_kivsee_2fproto_2frender_2fv1_2feffects_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_kivsee_2fproto_2frender_2fv1_2feffects_2eproto;
}  // extern "C"
namespace kivsee {
namespace proto {
namespace render {
namespace v1 {
class AlternateEffectConfig;
struct AlternateEffectConfigDefaultTypeInternal;
extern AlternateEffectConfigDefaultTypeInternal _AlternateEffectConfig_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull AlternateEffectConfig_class_data_;
class AnimationProto;
struct AnimationProtoDefaultTypeInternal;
extern AnimationProtoDefaultTypeInternal _AnimationProto_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull AnimationProto_class_data_;
class BrightnessEffectConfig;
struct BrightnessEffectConfigDefaultTypeInternal;
extern BrightnessEffectConfigDefaultTypeInternal _BrightnessEffectConfig_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull BrightnessEffectConfig_class_data_;
class ConstColorEffectConfig;
struct ConstColorEffectConfigDefaultTypeInternal;
extern ConstColorEffectConfigDefaultTypeInternal _ConstColorEffectConfig_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ConstColorEffectConfig_class_data_;
class EffectConfig;
struct EffectConfigDefaultTypeInternal;
extern EffectConfigDefaultTypeInternal _EffectConfig_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EffectConfig_class_data_;
class EffectProto;
struct EffectProtoDefaultTypeInternal;
extern EffectProtoDefaultTypeInternal _EffectProto_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EffectProto_class_data_;
class GlitterEffectConfig;
struct GlitterEffectConfigDefaultTypeInternal;
extern GlitterEffectConfigDefaultTypeInternal _GlitterEffectConfig_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GlitterEffectConfig_class_data_;
class HSV;
struct HSVDefaultTypeInternal;
extern HSVDefaultTypeInternal _HSV_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull HSV_class_data_;
class HueEffectConfig;
struct HueEffectConfigDefaultTypeInternal;
extern HueEffectConfigDefaultTypeInternal _HueEffectConfig_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull HueEffectConfig_class_data_;
class RainbowEffectConfig;
struct RainbowEffectConfigDefaultTypeInternal;
extern RainbowEffectConfigDefaultTypeInternal _RainbowEffectConfig_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RainbowEffectConfig_class_data_;
class SaturationEffectConfig;
struct SaturationEffectConfigDefaultTypeInternal;
extern SaturationEffectConfigDefaultTypeInternal _SaturationEffectConfig_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SaturationEffectConfig_class_data_;
class SegmentEffectConfig;
struct SegmentEffectConfigDefaultTypeInternal;
extern SegmentEffectConfigDefaultTypeInternal _SegmentEffectConfig_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SegmentEffectConfig_class_data_;
class SnakeEffectConfig;
struct SnakeEffectConfigDefaultTypeInternal;
extern SnakeEffectConfigDefaultTypeInternal _SnakeEffectConfig_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SnakeEffectConfig_class_data_;
}  // namespace v1
}  // namespace render
}  // namespace proto
}  // namespace kivsee
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace kivsee {
namespace proto {
namespace render {
namespace v1 {

// ===================================================================


// -------------------------------------------------------------------

class HSV final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kivsee.proto.render.v1.HSV) */ {
 public:
  inline HSV() : HSV(nullptr) {}
  ~HSV() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HSV* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HSV));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HSV(::google::protobuf::internal::ConstantInitialized);

  inline HSV(const HSV& from) : HSV(nullptr, from) {}
  inline HSV(HSV&& from) noexcept
      : HSV(nullptr, ::std::move(from)) {}
  inline HSV& operator=(const HSV& from) {
    CopyFrom(from);
    return *this;
  }
  inline HSV& operator=(HSV&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HSV& default_instance() {
    return *reinterpret_cast<const HSV*>(
        &_HSV_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(HSV& a, HSV& b) { a.Swap(&b); }
  inline void Swap(HSV* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HSV* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HSV* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<HSV>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HSV& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HSV& from) { HSV::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HSV* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kivsee.proto.render.v1.HSV"; }

 protected:
  explicit HSV(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  HSV(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const HSV& from);
  HSV(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, HSV&& from) noexcept
      : HSV(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHueFieldNumber = 1,
    kSatFieldNumber = 2,
    kValFieldNumber = 3,
  };
  // float hue = 1 [json_name = "hue"];
  void clear_hue() ;
  float hue() const;
  void set_hue(float value);

  private:
  float _internal_hue() const;
  void _internal_set_hue(float value);

  public:
  // float sat = 2 [json_name = "sat"];
  void clear_sat() ;
  float sat() const;
  void set_sat(float value);

  private:
  float _internal_sat() const;
  void _internal_set_sat(float value);

  public:
  // float val = 3 [json_name = "val"];
  void clear_val() ;
  float val() const;
  void set_val(float value);

  private:
  float _internal_val() const;
  void _internal_set_val(float value);

  public:
  // @@protoc_insertion_point(class_scope:kivsee.proto.render.v1.HSV)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const HSV& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    float hue_;
    float sat_;
    float val_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kivsee_2fproto_2frender_2fv1_2feffects_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull HSV_class_data_;
// -------------------------------------------------------------------

class EffectConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kivsee.proto.render.v1.EffectConfig) */ {
 public:
  inline EffectConfig() : EffectConfig(nullptr) {}
  ~EffectConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EffectConfig* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EffectConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EffectConfig(::google::protobuf::internal::ConstantInitialized);

  inline EffectConfig(const EffectConfig& from) : EffectConfig(nullptr, from) {}
  inline EffectConfig(EffectConfig&& from) noexcept
      : EffectConfig(nullptr, ::std::move(from)) {}
  inline EffectConfig& operator=(const EffectConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline EffectConfig& operator=(EffectConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EffectConfig& default_instance() {
    return *reinterpret_cast<const EffectConfig*>(
        &_EffectConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(EffectConfig& a, EffectConfig& b) { a.Swap(&b); }
  inline void Swap(EffectConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EffectConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EffectConfig* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EffectConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EffectConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EffectConfig& from) { EffectConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EffectConfig* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kivsee.proto.render.v1.EffectConfig"; }

 protected:
  explicit EffectConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EffectConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EffectConfig& from);
  EffectConfig(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EffectConfig&& from) noexcept
      : EffectConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSegmentsFieldNumber = 3,
    kStartTimeFieldNumber = 1,
    kEndTimeFieldNumber = 2,
    kRepeatNumFieldNumber = 4,
    kRepeatStartFieldNumber = 5,
    kRepeatEndFieldNumber = 6,
  };
  // string segments = 3 [json_name = "segments"];
  void clear_segments() ;
  const ::std::string& segments() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_segments(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_segments();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_segments();
  void set_allocated_segments(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_segments() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_segments(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_segments();

  public:
  // uint32 start_time = 1 [json_name = "startTime"];
  void clear_start_time() ;
  ::uint32_t start_time() const;
  void set_start_time(::uint32_t value);

  private:
  ::uint32_t _internal_start_time() const;
  void _internal_set_start_time(::uint32_t value);

  public:
  // uint32 end_time = 2 [json_name = "endTime"];
  void clear_end_time() ;
  ::uint32_t end_time() const;
  void set_end_time(::uint32_t value);

  private:
  ::uint32_t _internal_end_time() const;
  void _internal_set_end_time(::uint32_t value);

  public:
  // float repeat_num = 4 [json_name = "repeatNum"];
  void clear_repeat_num() ;
  float repeat_num() const;
  void set_repeat_num(float value);

  private:
  float _internal_repeat_num() const;
  void _internal_set_repeat_num(float value);

  public:
  // float repeat_start = 5 [json_name = "repeatStart"];
  void clear_repeat_start() ;
  float repeat_start() const;
  void set_repeat_start(float value);

  private:
  float _internal_repeat_start() const;
  void _internal_set_repeat_start(float value);

  public:
  // float repeat_end = 6 [json_name = "repeatEnd"];
  void clear_repeat_end() ;
  float repeat_end() const;
  void set_repeat_end(float value);

  private:
  float _internal_repeat_end() const;
  void _internal_set_repeat_end(float value);

  public:
  // @@protoc_insertion_point(class_scope:kivsee.proto.render.v1.EffectConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   0, 52,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EffectConfig& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr segments_;
    ::uint32_t start_time_;
    ::uint32_t end_time_;
    float repeat_num_;
    float repeat_start_;
    float repeat_end_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kivsee_2fproto_2frender_2fv1_2feffects_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EffectConfig_class_data_;
// -------------------------------------------------------------------

class ConstColorEffectConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kivsee.proto.render.v1.ConstColorEffectConfig) */ {
 public:
  inline ConstColorEffectConfig() : ConstColorEffectConfig(nullptr) {}
  ~ConstColorEffectConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ConstColorEffectConfig* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ConstColorEffectConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ConstColorEffectConfig(::google::protobuf::internal::ConstantInitialized);

  inline ConstColorEffectConfig(const ConstColorEffectConfig& from) : ConstColorEffectConfig(nullptr, from) {}
  inline ConstColorEffectConfig(ConstColorEffectConfig&& from) noexcept
      : ConstColorEffectConfig(nullptr, ::std::move(from)) {}
  inline ConstColorEffectConfig& operator=(const ConstColorEffectConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConstColorEffectConfig& operator=(ConstColorEffectConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConstColorEffectConfig& default_instance() {
    return *reinterpret_cast<const ConstColorEffectConfig*>(
        &_ConstColorEffectConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(ConstColorEffectConfig& a, ConstColorEffectConfig& b) { a.Swap(&b); }
  inline void Swap(ConstColorEffectConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConstColorEffectConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConstColorEffectConfig* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ConstColorEffectConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ConstColorEffectConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ConstColorEffectConfig& from) { ConstColorEffectConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ConstColorEffectConfig* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kivsee.proto.render.v1.ConstColorEffectConfig"; }

 protected:
  explicit ConstColorEffectConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ConstColorEffectConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ConstColorEffectConfig& from);
  ConstColorEffectConfig(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ConstColorEffectConfig&& from) noexcept
      : ConstColorEffectConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kColorFieldNumber = 1,
  };
  // .kivsee.proto.render.v1.HSV color = 1 [json_name = "color"];
  bool has_color() const;
  void clear_color() ;
  const ::kivsee::proto::render::v1::HSV& color() const;
  [[nodiscard]] ::kivsee::proto::render::v1::HSV* PROTOBUF_NULLABLE release_color();
  ::kivsee::proto::render::v1::HSV* PROTOBUF_NONNULL mutable_color();
  void set_allocated_color(::kivsee::proto::render::v1::HSV* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_color(::kivsee::proto::render::v1::HSV* PROTOBUF_NULLABLE value);
  ::kivsee::proto::render::v1::HSV* PROTOBUF_NULLABLE unsafe_arena_release_color();

  private:
  const ::kivsee::proto::render::v1::HSV& _internal_color() const;
  ::kivsee::proto::render::v1::HSV* PROTOBUF_NONNULL _internal_mutable_color();

  public:
  // @@protoc_insertion_point(class_scope:kivsee.proto.render.v1.ConstColorEffectConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ConstColorEffectConfig& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::kivsee::proto::render::v1::HSV* PROTOBUF_NULLABLE color_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kivsee_2fproto_2frender_2fv1_2feffects_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ConstColorEffectConfig_class_data_;
// -------------------------------------------------------------------

class SnakeEffectConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kivsee.proto.render.v1.SnakeEffectConfig) */ {
 public:
  inline SnakeEffectConfig() : SnakeEffectConfig(nullptr) {}
  ~SnakeEffectConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SnakeEffectConfig* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SnakeEffectConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SnakeEffectConfig(::google::protobuf::internal::ConstantInitialized);

  inline SnakeEffectConfig(const SnakeEffectConfig& from) : SnakeEffectConfig(nullptr, from) {}
  inline SnakeEffectConfig(SnakeEffectConfig&& from) noexcept
      : SnakeEffectConfig(nullptr, ::std::move(from)) {}
  inline SnakeEffectConfig& operator=(const SnakeEffectConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnakeEffectConfig& operator=(SnakeEffectConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SnakeEffectConfig& default_instance() {
    return *reinterpret_cast<const SnakeEffectConfig*>(
        &_SnakeEffectConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(SnakeEffectConfig& a, SnakeEffectConfig& b) { a.Swap(&b); }
  inline void Swap(SnakeEffectConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SnakeEffectConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SnakeEffectConfig* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SnakeEffectConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SnakeEffectConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SnakeEffectConfig& from) { SnakeEffectConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SnakeEffectConfig* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kivsee.proto.render.v1.SnakeEffectConfig"; }

 protected:
  explicit SnakeEffectConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SnakeEffectConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SnakeEffectConfig& from);
  SnakeEffectConfig(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SnakeEffectConfig&& from) noexcept
      : SnakeEffectConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHeadFieldNumber = 1,
    kTailLengthFieldNumber = 2,
    kCyclicFieldNumber = 3,
  };
  // .kivsee.proto.render.v1.FloatFunction head = 1 [json_name = "head"];
  bool has_head() const;
  void clear_head() ;
  const ::kivsee::proto::render::v1::FloatFunction& head() const;
  [[nodiscard]] ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE release_head();
  ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL mutable_head();
  void set_allocated_head(::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_head(::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value);
  ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE unsafe_arena_release_head();

  private:
  const ::kivsee::proto::render::v1::FloatFunction& _internal_head() const;
  ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL _internal_mutable_head();

  public:
  // .kivsee.proto.render.v1.FloatFunction tail_length = 2 [json_name = "tailLength"];
  bool has_tail_length() const;
  void clear_tail_length() ;
  const ::kivsee::proto::render::v1::FloatFunction& tail_length() const;
  [[nodiscard]] ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE release_tail_length();
  ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL mutable_tail_length();
  void set_allocated_tail_length(::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_tail_length(::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value);
  ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE unsafe_arena_release_tail_length();

  private:
  const ::kivsee::proto::render::v1::FloatFunction& _internal_tail_length() const;
  ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL _internal_mutable_tail_length();

  public:
  // bool cyclic = 3 [json_name = "cyclic"];
  void clear_cyclic() ;
  bool cyclic() const;
  void set_cyclic(bool value);

  private:
  bool _internal_cyclic() const;
  void _internal_set_cyclic(bool value);

  public:
  // @@protoc_insertion_point(class_scope:kivsee.proto.render.v1.SnakeEffectConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SnakeEffectConfig& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE head_;
    ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE tail_length_;
    bool cyclic_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kivsee_2fproto_2frender_2fv1_2feffects_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SnakeEffectConfig_class_data_;
// -------------------------------------------------------------------

class SegmentEffectConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kivsee.proto.render.v1.SegmentEffectConfig) */ {
 public:
  inline SegmentEffectConfig() : SegmentEffectConfig(nullptr) {}
  ~SegmentEffectConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SegmentEffectConfig* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SegmentEffectConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SegmentEffectConfig(::google::protobuf::internal::ConstantInitialized);

  inline SegmentEffectConfig(const SegmentEffectConfig& from) : SegmentEffectConfig(nullptr, from) {}
  inline SegmentEffectConfig(SegmentEffectConfig&& from) noexcept
      : SegmentEffectConfig(nullptr, ::std::move(from)) {}
  inline SegmentEffectConfig& operator=(const SegmentEffectConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline SegmentEffectConfig& operator=(SegmentEffectConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SegmentEffectConfig& default_instance() {
    return *reinterpret_cast<const SegmentEffectConfig*>(
        &_SegmentEffectConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(SegmentEffectConfig& a, SegmentEffectConfig& b) { a.Swap(&b); }
  inline void Swap(SegmentEffectConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SegmentEffectConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SegmentEffectConfig* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SegmentEffectConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SegmentEffectConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SegmentEffectConfig& from) { SegmentEffectConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SegmentEffectConfig* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kivsee.proto.render.v1.SegmentEffectConfig"; }

 protected:
  explicit SegmentEffectConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SegmentEffectConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SegmentEffectConfig& from);
  SegmentEffectConfig(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SegmentEffectConfig&& from) noexcept
      : SegmentEffectConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
  };
  // .kivsee.proto.render.v1.FloatFunction start = 1 [json_name = "start"];
  bool has_start() const;
  void clear_start() ;
  const ::kivsee::proto::render::v1::FloatFunction& start() const;
  [[nodiscard]] ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE release_start();
  ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL mutable_start();
  void set_allocated_start(::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_start(::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value);
  ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE unsafe_arena_release_start();

  private:
  const ::kivsee::proto::render::v1::FloatFunction& _internal_start() const;
  ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL _internal_mutable_start();

  public:
  // .kivsee.proto.render.v1.FloatFunction end = 2 [json_name = "end"];
  bool has_end() const;
  void clear_end() ;
  const ::kivsee::proto::render::v1::FloatFunction& end() const;
  [[nodiscard]] ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE release_end();
  ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL mutable_end();
  void set_allocated_end(::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_end(::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value);
  ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE unsafe_arena_release_end();

  private:
  const ::kivsee::proto::render::v1::FloatFunction& _internal_end() const;
  ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL _internal_mutable_end();

  public:
  // @@protoc_insertion_point(class_scope:kivsee.proto.render.v1.SegmentEffectConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SegmentEffectConfig& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE start_;
    ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE end_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kivsee_2fproto_2frender_2fv1_2feffects_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SegmentEffectConfig_class_data_;
// -------------------------------------------------------------------

class SaturationEffectConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kivsee.proto.render.v1.SaturationEffectConfig) */ {
 public:
  inline SaturationEffectConfig() : SaturationEffectConfig(nullptr) {}
  ~SaturationEffectConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SaturationEffectConfig* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SaturationEffectConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SaturationEffectConfig(::google::protobuf::internal::ConstantInitialized);

  inline SaturationEffectConfig(const SaturationEffectConfig& from) : SaturationEffectConfig(nullptr, from) {}
  inline SaturationEffectConfig(SaturationEffectConfig&& from) noexcept
      : SaturationEffectConfig(nullptr, ::std::move(from)) {}
  inline SaturationEffectConfig& operator=(const SaturationEffectConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline SaturationEffectConfig& operator=(SaturationEffectConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SaturationEffectConfig& default_instance() {
    return *reinterpret_cast<const SaturationEffectConfig*>(
        &_SaturationEffectConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(SaturationEffectConfig& a, SaturationEffectConfig& b) { a.Swap(&b); }
  inline void Swap(SaturationEffectConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SaturationEffectConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SaturationEffectConfig* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SaturationEffectConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SaturationEffectConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SaturationEffectConfig& from) { SaturationEffectConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SaturationEffectConfig* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kivsee.proto.render.v1.SaturationEffectConfig"; }

 protected:
  explicit SaturationEffectConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SaturationEffectConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SaturationEffectConfig& from);
  SaturationEffectConfig(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SaturationEffectConfig&& from) noexcept
      : SaturationEffectConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMultFactorFieldNumber = 1,
  };
  // .kivsee.proto.render.v1.FloatFunction mult_factor = 1 [json_name = "multFactor"];
  bool has_mult_factor() const;
  void clear_mult_factor() ;
  const ::kivsee::proto::render::v1::FloatFunction& mult_factor() const;
  [[nodiscard]] ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE release_mult_factor();
  ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL mutable_mult_factor();
  void set_allocated_mult_factor(::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_mult_factor(::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value);
  ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE unsafe_arena_release_mult_factor();

  private:
  const ::kivsee::proto::render::v1::FloatFunction& _internal_mult_factor() const;
  ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL _internal_mutable_mult_factor();

  public:
  // @@protoc_insertion_point(class_scope:kivsee.proto.render.v1.SaturationEffectConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SaturationEffectConfig& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE mult_factor_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kivsee_2fproto_2frender_2fv1_2feffects_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SaturationEffectConfig_class_data_;
// -------------------------------------------------------------------

class RainbowEffectConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kivsee.proto.render.v1.RainbowEffectConfig) */ {
 public:
  inline RainbowEffectConfig() : RainbowEffectConfig(nullptr) {}
  ~RainbowEffectConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RainbowEffectConfig* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RainbowEffectConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RainbowEffectConfig(::google::protobuf::internal::ConstantInitialized);

  inline RainbowEffectConfig(const RainbowEffectConfig& from) : RainbowEffectConfig(nullptr, from) {}
  inline RainbowEffectConfig(RainbowEffectConfig&& from) noexcept
      : RainbowEffectConfig(nullptr, ::std::move(from)) {}
  inline RainbowEffectConfig& operator=(const RainbowEffectConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline RainbowEffectConfig& operator=(RainbowEffectConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RainbowEffectConfig& default_instance() {
    return *reinterpret_cast<const RainbowEffectConfig*>(
        &_RainbowEffectConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(RainbowEffectConfig& a, RainbowEffectConfig& b) { a.Swap(&b); }
  inline void Swap(RainbowEffectConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RainbowEffectConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RainbowEffectConfig* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RainbowEffectConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RainbowEffectConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RainbowEffectConfig& from) { RainbowEffectConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RainbowEffectConfig* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kivsee.proto.render.v1.RainbowEffectConfig"; }

 protected:
  explicit RainbowEffectConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RainbowEffectConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RainbowEffectConfig& from);
  RainbowEffectConfig(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RainbowEffectConfig&& from) noexcept
      : RainbowEffectConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHueStartFieldNumber = 1,
    kHueEndFieldNumber = 2,
  };
  // .kivsee.proto.render.v1.FloatFunction hue_start = 1 [json_name = "hueStart"];
  bool has_hue_start() const;
  void clear_hue_start() ;
  const ::kivsee::proto::render::v1::FloatFunction& hue_start() const;
  [[nodiscard]] ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE release_hue_start();
  ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL mutable_hue_start();
  void set_allocated_hue_start(::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_hue_start(::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value);
  ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE unsafe_arena_release_hue_start();

  private:
  const ::kivsee::proto::render::v1::FloatFunction& _internal_hue_start() const;
  ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL _internal_mutable_hue_start();

  public:
  // .kivsee.proto.render.v1.FloatFunction hue_end = 2 [json_name = "hueEnd"];
  bool has_hue_end() const;
  void clear_hue_end() ;
  const ::kivsee::proto::render::v1::FloatFunction& hue_end() const;
  [[nodiscard]] ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE release_hue_end();
  ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL mutable_hue_end();
  void set_allocated_hue_end(::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_hue_end(::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value);
  ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE unsafe_arena_release_hue_end();

  private:
  const ::kivsee::proto::render::v1::FloatFunction& _internal_hue_end() const;
  ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL _internal_mutable_hue_end();

  public:
  // @@protoc_insertion_point(class_scope:kivsee.proto.render.v1.RainbowEffectConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RainbowEffectConfig& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE hue_start_;
    ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE hue_end_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kivsee_2fproto_2frender_2fv1_2feffects_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RainbowEffectConfig_class_data_;
// -------------------------------------------------------------------

class HueEffectConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kivsee.proto.render.v1.HueEffectConfig) */ {
 public:
  inline HueEffectConfig() : HueEffectConfig(nullptr) {}
  ~HueEffectConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HueEffectConfig* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HueEffectConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HueEffectConfig(::google::protobuf::internal::ConstantInitialized);

  inline HueEffectConfig(const HueEffectConfig& from) : HueEffectConfig(nullptr, from) {}
  inline HueEffectConfig(HueEffectConfig&& from) noexcept
      : HueEffectConfig(nullptr, ::std::move(from)) {}
  inline HueEffectConfig& operator=(const HueEffectConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline HueEffectConfig& operator=(HueEffectConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HueEffectConfig& default_instance() {
    return *reinterpret_cast<const HueEffectConfig*>(
        &_HueEffectConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(HueEffectConfig& a, HueEffectConfig& b) { a.Swap(&b); }
  inline void Swap(HueEffectConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HueEffectConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HueEffectConfig* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<HueEffectConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HueEffectConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HueEffectConfig& from) { HueEffectConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HueEffectConfig* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kivsee.proto.render.v1.HueEffectConfig"; }

 protected:
  explicit HueEffectConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  HueEffectConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const HueEffectConfig& from);
  HueEffectConfig(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, HueEffectConfig&& from) noexcept
      : HueEffectConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOffsetFactorFieldNumber = 1,
  };
  // .kivsee.proto.render.v1.FloatFunction offset_factor = 1 [json_name = "offsetFactor"];
  bool has_offset_factor() const;
  void clear_offset_factor() ;
  const ::kivsee::proto::render::v1::FloatFunction& offset_factor() const;
  [[nodiscard]] ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE release_offset_factor();
  ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL mutable_offset_factor();
  void set_allocated_offset_factor(::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_offset_factor(::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value);
  ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE unsafe_arena_release_offset_factor();

  private:
  const ::kivsee::proto::render::v1::FloatFunction& _internal_offset_factor() const;
  ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL _internal_mutable_offset_factor();

  public:
  // @@protoc_insertion_point(class_scope:kivsee.proto.render.v1.HueEffectConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const HueEffectConfig& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE offset_factor_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kivsee_2fproto_2frender_2fv1_2feffects_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull HueEffectConfig_class_data_;
// -------------------------------------------------------------------

class GlitterEffectConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kivsee.proto.render.v1.GlitterEffectConfig) */ {
 public:
  inline GlitterEffectConfig() : GlitterEffectConfig(nullptr) {}
  ~GlitterEffectConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GlitterEffectConfig* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GlitterEffectConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GlitterEffectConfig(::google::protobuf::internal::ConstantInitialized);

  inline GlitterEffectConfig(const GlitterEffectConfig& from) : GlitterEffectConfig(nullptr, from) {}
  inline GlitterEffectConfig(GlitterEffectConfig&& from) noexcept
      : GlitterEffectConfig(nullptr, ::std::move(from)) {}
  inline GlitterEffectConfig& operator=(const GlitterEffectConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline GlitterEffectConfig& operator=(GlitterEffectConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GlitterEffectConfig& default_instance() {
    return *reinterpret_cast<const GlitterEffectConfig*>(
        &_GlitterEffectConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(GlitterEffectConfig& a, GlitterEffectConfig& b) { a.Swap(&b); }
  inline void Swap(GlitterEffectConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GlitterEffectConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GlitterEffectConfig* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GlitterEffectConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GlitterEffectConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GlitterEffectConfig& from) { GlitterEffectConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GlitterEffectConfig* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kivsee.proto.render.v1.GlitterEffectConfig"; }

 protected:
  explicit GlitterEffectConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GlitterEffectConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GlitterEffectConfig& from);
  GlitterEffectConfig(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GlitterEffectConfig&& from) noexcept
      : GlitterEffectConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIntensityFieldNumber = 1,
    kSatMultFactorFieldNumber = 2,
  };
  // .kivsee.proto.render.v1.FloatFunction intensity = 1 [json_name = "intensity"];
  bool has_intensity() const;
  void clear_intensity() ;
  const ::kivsee::proto::render::v1::FloatFunction& intensity() const;
  [[nodiscard]] ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE release_intensity();
  ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL mutable_intensity();
  void set_allocated_intensity(::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_intensity(::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value);
  ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE unsafe_arena_release_intensity();

  private:
  const ::kivsee::proto::render::v1::FloatFunction& _internal_intensity() const;
  ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL _internal_mutable_intensity();

  public:
  // .kivsee.proto.render.v1.FloatFunction sat_mult_factor = 2 [json_name = "satMultFactor"];
  bool has_sat_mult_factor() const;
  void clear_sat_mult_factor() ;
  const ::kivsee::proto::render::v1::FloatFunction& sat_mult_factor() const;
  [[nodiscard]] ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE release_sat_mult_factor();
  ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL mutable_sat_mult_factor();
  void set_allocated_sat_mult_factor(::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_sat_mult_factor(::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value);
  ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE unsafe_arena_release_sat_mult_factor();

  private:
  const ::kivsee::proto::render::v1::FloatFunction& _internal_sat_mult_factor() const;
  ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL _internal_mutable_sat_mult_factor();

  public:
  // @@protoc_insertion_point(class_scope:kivsee.proto.render.v1.GlitterEffectConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GlitterEffectConfig& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE intensity_;
    ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE sat_mult_factor_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kivsee_2fproto_2frender_2fv1_2feffects_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GlitterEffectConfig_class_data_;
// -------------------------------------------------------------------

class BrightnessEffectConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kivsee.proto.render.v1.BrightnessEffectConfig) */ {
 public:
  inline BrightnessEffectConfig() : BrightnessEffectConfig(nullptr) {}
  ~BrightnessEffectConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BrightnessEffectConfig* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BrightnessEffectConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BrightnessEffectConfig(::google::protobuf::internal::ConstantInitialized);

  inline BrightnessEffectConfig(const BrightnessEffectConfig& from) : BrightnessEffectConfig(nullptr, from) {}
  inline BrightnessEffectConfig(BrightnessEffectConfig&& from) noexcept
      : BrightnessEffectConfig(nullptr, ::std::move(from)) {}
  inline BrightnessEffectConfig& operator=(const BrightnessEffectConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline BrightnessEffectConfig& operator=(BrightnessEffectConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BrightnessEffectConfig& default_instance() {
    return *reinterpret_cast<const BrightnessEffectConfig*>(
        &_BrightnessEffectConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(BrightnessEffectConfig& a, BrightnessEffectConfig& b) { a.Swap(&b); }
  inline void Swap(BrightnessEffectConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BrightnessEffectConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BrightnessEffectConfig* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BrightnessEffectConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BrightnessEffectConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BrightnessEffectConfig& from) { BrightnessEffectConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BrightnessEffectConfig* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kivsee.proto.render.v1.BrightnessEffectConfig"; }

 protected:
  explicit BrightnessEffectConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  BrightnessEffectConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const BrightnessEffectConfig& from);
  BrightnessEffectConfig(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, BrightnessEffectConfig&& from) noexcept
      : BrightnessEffectConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMultFactorFieldNumber = 1,
  };
  // .kivsee.proto.render.v1.FloatFunction mult_factor = 1 [json_name = "multFactor"];
  bool has_mult_factor() const;
  void clear_mult_factor() ;
  const ::kivsee::proto::render::v1::FloatFunction& mult_factor() const;
  [[nodiscard]] ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE release_mult_factor();
  ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL mutable_mult_factor();
  void set_allocated_mult_factor(::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_mult_factor(::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value);
  ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE unsafe_arena_release_mult_factor();

  private:
  const ::kivsee::proto::render::v1::FloatFunction& _internal_mult_factor() const;
  ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL _internal_mutable_mult_factor();

  public:
  // @@protoc_insertion_point(class_scope:kivsee.proto.render.v1.BrightnessEffectConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const BrightnessEffectConfig& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE mult_factor_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kivsee_2fproto_2frender_2fv1_2feffects_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull BrightnessEffectConfig_class_data_;
// -------------------------------------------------------------------

class AlternateEffectConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kivsee.proto.render.v1.AlternateEffectConfig) */ {
 public:
  inline AlternateEffectConfig() : AlternateEffectConfig(nullptr) {}
  ~AlternateEffectConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AlternateEffectConfig* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AlternateEffectConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AlternateEffectConfig(::google::protobuf::internal::ConstantInitialized);

  inline AlternateEffectConfig(const AlternateEffectConfig& from) : AlternateEffectConfig(nullptr, from) {}
  inline AlternateEffectConfig(AlternateEffectConfig&& from) noexcept
      : AlternateEffectConfig(nullptr, ::std::move(from)) {}
  inline AlternateEffectConfig& operator=(const AlternateEffectConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline AlternateEffectConfig& operator=(AlternateEffectConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AlternateEffectConfig& default_instance() {
    return *reinterpret_cast<const AlternateEffectConfig*>(
        &_AlternateEffectConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(AlternateEffectConfig& a, AlternateEffectConfig& b) { a.Swap(&b); }
  inline void Swap(AlternateEffectConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AlternateEffectConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AlternateEffectConfig* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AlternateEffectConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AlternateEffectConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AlternateEffectConfig& from) { AlternateEffectConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AlternateEffectConfig* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kivsee.proto.render.v1.AlternateEffectConfig"; }

 protected:
  explicit AlternateEffectConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  AlternateEffectConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const AlternateEffectConfig& from);
  AlternateEffectConfig(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, AlternateEffectConfig&& from) noexcept
      : AlternateEffectConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHueOffsetFieldNumber = 2,
    kSatMultFieldNumber = 3,
    kBrightnessMultFieldNumber = 4,
    kNumberOfPixelsFieldNumber = 1,
  };
  // .kivsee.proto.render.v1.FloatFunction hue_offset = 2 [json_name = "hueOffset"];
  bool has_hue_offset() const;
  void clear_hue_offset() ;
  const ::kivsee::proto::render::v1::FloatFunction& hue_offset() const;
  [[nodiscard]] ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE release_hue_offset();
  ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL mutable_hue_offset();
  void set_allocated_hue_offset(::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_hue_offset(::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value);
  ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE unsafe_arena_release_hue_offset();

  private:
  const ::kivsee::proto::render::v1::FloatFunction& _internal_hue_offset() const;
  ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL _internal_mutable_hue_offset();

  public:
  // .kivsee.proto.render.v1.FloatFunction sat_mult = 3 [json_name = "satMult"];
  bool has_sat_mult() const;
  void clear_sat_mult() ;
  const ::kivsee::proto::render::v1::FloatFunction& sat_mult() const;
  [[nodiscard]] ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE release_sat_mult();
  ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL mutable_sat_mult();
  void set_allocated_sat_mult(::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_sat_mult(::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value);
  ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE unsafe_arena_release_sat_mult();

  private:
  const ::kivsee::proto::render::v1::FloatFunction& _internal_sat_mult() const;
  ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL _internal_mutable_sat_mult();

  public:
  // .kivsee.proto.render.v1.FloatFunction brightness_mult = 4 [json_name = "brightnessMult"];
  bool has_brightness_mult() const;
  void clear_brightness_mult() ;
  const ::kivsee::proto::render::v1::FloatFunction& brightness_mult() const;
  [[nodiscard]] ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE release_brightness_mult();
  ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL mutable_brightness_mult();
  void set_allocated_brightness_mult(::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_brightness_mult(::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value);
  ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE unsafe_arena_release_brightness_mult();

  private:
  const ::kivsee::proto::render::v1::FloatFunction& _internal_brightness_mult() const;
  ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL _internal_mutable_brightness_mult();

  public:
  // uint32 numberOfPixels = 1 [json_name = "numberOfPixels"];
  void clear_numberofpixels() ;
  ::uint32_t numberofpixels() const;
  void set_numberofpixels(::uint32_t value);

  private:
  ::uint32_t _internal_numberofpixels() const;
  void _internal_set_numberofpixels(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:kivsee.proto.render.v1.AlternateEffectConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const AlternateEffectConfig& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE hue_offset_;
    ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE sat_mult_;
    ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE brightness_mult_;
    ::uint32_t numberofpixels_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kivsee_2fproto_2frender_2fv1_2feffects_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull AlternateEffectConfig_class_data_;
// -------------------------------------------------------------------

class EffectProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kivsee.proto.render.v1.EffectProto) */ {
 public:
  inline EffectProto() : EffectProto(nullptr) {}
  ~EffectProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EffectProto* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EffectProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EffectProto(::google::protobuf::internal::ConstantInitialized);

  inline EffectProto(const EffectProto& from) : EffectProto(nullptr, from) {}
  inline EffectProto(EffectProto&& from) noexcept
      : EffectProto(nullptr, ::std::move(from)) {}
  inline EffectProto& operator=(const EffectProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline EffectProto& operator=(EffectProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EffectProto& default_instance() {
    return *reinterpret_cast<const EffectProto*>(
        &_EffectProto_default_instance_);
  }
  enum EffectCase {
    kConstColor = 2,
    kRainbow = 3,
    kBrightness = 4,
    kHue = 5,
    kSaturation = 6,
    kSnake = 7,
    EFFECT_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(EffectProto& a, EffectProto& b) { a.Swap(&b); }
  inline void Swap(EffectProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EffectProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EffectProto* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EffectProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EffectProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EffectProto& from) { EffectProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EffectProto* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kivsee.proto.render.v1.EffectProto"; }

 protected:
  explicit EffectProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EffectProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EffectProto& from);
  EffectProto(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EffectProto&& from) noexcept
      : EffectProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEffectConfigFieldNumber = 1,
    kConstColorFieldNumber = 2,
    kRainbowFieldNumber = 3,
    kBrightnessFieldNumber = 4,
    kHueFieldNumber = 5,
    kSaturationFieldNumber = 6,
    kSnakeFieldNumber = 7,
  };
  // .kivsee.proto.render.v1.EffectConfig effect_config = 1 [json_name = "effectConfig"];
  bool has_effect_config() const;
  void clear_effect_config() ;
  const ::kivsee::proto::render::v1::EffectConfig& effect_config() const;
  [[nodiscard]] ::kivsee::proto::render::v1::EffectConfig* PROTOBUF_NULLABLE release_effect_config();
  ::kivsee::proto::render::v1::EffectConfig* PROTOBUF_NONNULL mutable_effect_config();
  void set_allocated_effect_config(::kivsee::proto::render::v1::EffectConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_effect_config(::kivsee::proto::render::v1::EffectConfig* PROTOBUF_NULLABLE value);
  ::kivsee::proto::render::v1::EffectConfig* PROTOBUF_NULLABLE unsafe_arena_release_effect_config();

  private:
  const ::kivsee::proto::render::v1::EffectConfig& _internal_effect_config() const;
  ::kivsee::proto::render::v1::EffectConfig* PROTOBUF_NONNULL _internal_mutable_effect_config();

  public:
  // .kivsee.proto.render.v1.ConstColorEffectConfig const_color = 2 [json_name = "constColor"];
  bool has_const_color() const;
  private:
  bool _internal_has_const_color() const;

  public:
  void clear_const_color() ;
  const ::kivsee::proto::render::v1::ConstColorEffectConfig& const_color() const;
  [[nodiscard]] ::kivsee::proto::render::v1::ConstColorEffectConfig* PROTOBUF_NULLABLE release_const_color();
  ::kivsee::proto::render::v1::ConstColorEffectConfig* PROTOBUF_NONNULL mutable_const_color();
  void set_allocated_const_color(::kivsee::proto::render::v1::ConstColorEffectConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_const_color(::kivsee::proto::render::v1::ConstColorEffectConfig* PROTOBUF_NULLABLE value);
  ::kivsee::proto::render::v1::ConstColorEffectConfig* PROTOBUF_NULLABLE unsafe_arena_release_const_color();

  private:
  const ::kivsee::proto::render::v1::ConstColorEffectConfig& _internal_const_color() const;
  ::kivsee::proto::render::v1::ConstColorEffectConfig* PROTOBUF_NONNULL _internal_mutable_const_color();

  public:
  // .kivsee.proto.render.v1.RainbowEffectConfig rainbow = 3 [json_name = "rainbow"];
  bool has_rainbow() const;
  private:
  bool _internal_has_rainbow() const;

  public:
  void clear_rainbow() ;
  const ::kivsee::proto::render::v1::RainbowEffectConfig& rainbow() const;
  [[nodiscard]] ::kivsee::proto::render::v1::RainbowEffectConfig* PROTOBUF_NULLABLE release_rainbow();
  ::kivsee::proto::render::v1::RainbowEffectConfig* PROTOBUF_NONNULL mutable_rainbow();
  void set_allocated_rainbow(::kivsee::proto::render::v1::RainbowEffectConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_rainbow(::kivsee::proto::render::v1::RainbowEffectConfig* PROTOBUF_NULLABLE value);
  ::kivsee::proto::render::v1::RainbowEffectConfig* PROTOBUF_NULLABLE unsafe_arena_release_rainbow();

  private:
  const ::kivsee::proto::render::v1::RainbowEffectConfig& _internal_rainbow() const;
  ::kivsee::proto::render::v1::RainbowEffectConfig* PROTOBUF_NONNULL _internal_mutable_rainbow();

  public:
  // .kivsee.proto.render.v1.BrightnessEffectConfig brightness = 4 [json_name = "brightness"];
  bool has_brightness() const;
  private:
  bool _internal_has_brightness() const;

  public:
  void clear_brightness() ;
  const ::kivsee::proto::render::v1::BrightnessEffectConfig& brightness() const;
  [[nodiscard]] ::kivsee::proto::render::v1::BrightnessEffectConfig* PROTOBUF_NULLABLE release_brightness();
  ::kivsee::proto::render::v1::BrightnessEffectConfig* PROTOBUF_NONNULL mutable_brightness();
  void set_allocated_brightness(::kivsee::proto::render::v1::BrightnessEffectConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_brightness(::kivsee::proto::render::v1::BrightnessEffectConfig* PROTOBUF_NULLABLE value);
  ::kivsee::proto::render::v1::BrightnessEffectConfig* PROTOBUF_NULLABLE unsafe_arena_release_brightness();

  private:
  const ::kivsee::proto::render::v1::BrightnessEffectConfig& _internal_brightness() const;
  ::kivsee::proto::render::v1::BrightnessEffectConfig* PROTOBUF_NONNULL _internal_mutable_brightness();

  public:
  // .kivsee.proto.render.v1.HueEffectConfig hue = 5 [json_name = "hue"];
  bool has_hue() const;
  private:
  bool _internal_has_hue() const;

  public:
  void clear_hue() ;
  const ::kivsee::proto::render::v1::HueEffectConfig& hue() const;
  [[nodiscard]] ::kivsee::proto::render::v1::HueEffectConfig* PROTOBUF_NULLABLE release_hue();
  ::kivsee::proto::render::v1::HueEffectConfig* PROTOBUF_NONNULL mutable_hue();
  void set_allocated_hue(::kivsee::proto::render::v1::HueEffectConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_hue(::kivsee::proto::render::v1::HueEffectConfig* PROTOBUF_NULLABLE value);
  ::kivsee::proto::render::v1::HueEffectConfig* PROTOBUF_NULLABLE unsafe_arena_release_hue();

  private:
  const ::kivsee::proto::render::v1::HueEffectConfig& _internal_hue() const;
  ::kivsee::proto::render::v1::HueEffectConfig* PROTOBUF_NONNULL _internal_mutable_hue();

  public:
  // .kivsee.proto.render.v1.SaturationEffectConfig saturation = 6 [json_name = "saturation"];
  bool has_saturation() const;
  private:
  bool _internal_has_saturation() const;

  public:
  void clear_saturation() ;
  const ::kivsee::proto::render::v1::SaturationEffectConfig& saturation() const;
  [[nodiscard]] ::kivsee::proto::render::v1::SaturationEffectConfig* PROTOBUF_NULLABLE release_saturation();
  ::kivsee::proto::render::v1::SaturationEffectConfig* PROTOBUF_NONNULL mutable_saturation();
  void set_allocated_saturation(::kivsee::proto::render::v1::SaturationEffectConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_saturation(::kivsee::proto::render::v1::SaturationEffectConfig* PROTOBUF_NULLABLE value);
  ::kivsee::proto::render::v1::SaturationEffectConfig* PROTOBUF_NULLABLE unsafe_arena_release_saturation();

  private:
  const ::kivsee::proto::render::v1::SaturationEffectConfig& _internal_saturation() const;
  ::kivsee::proto::render::v1::SaturationEffectConfig* PROTOBUF_NONNULL _internal_mutable_saturation();

  public:
  // .kivsee.proto.render.v1.SnakeEffectConfig snake = 7 [json_name = "snake"];
  bool has_snake() const;
  private:
  bool _internal_has_snake() const;

  public:
  void clear_snake() ;
  const ::kivsee::proto::render::v1::SnakeEffectConfig& snake() const;
  [[nodiscard]] ::kivsee::proto::render::v1::SnakeEffectConfig* PROTOBUF_NULLABLE release_snake();
  ::kivsee::proto::render::v1::SnakeEffectConfig* PROTOBUF_NONNULL mutable_snake();
  void set_allocated_snake(::kivsee::proto::render::v1::SnakeEffectConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_snake(::kivsee::proto::render::v1::SnakeEffectConfig* PROTOBUF_NULLABLE value);
  ::kivsee::proto::render::v1::SnakeEffectConfig* PROTOBUF_NULLABLE unsafe_arena_release_snake();

  private:
  const ::kivsee::proto::render::v1::SnakeEffectConfig& _internal_snake() const;
  ::kivsee::proto::render::v1::SnakeEffectConfig* PROTOBUF_NONNULL _internal_mutable_snake();

  public:
  void clear_effect();
  EffectCase effect_case() const;
  // @@protoc_insertion_point(class_scope:kivsee.proto.render.v1.EffectProto)
 private:
  class _Internal;
  void set_has_const_color();
  void set_has_rainbow();
  void set_has_brightness();
  void set_has_hue();
  void set_has_saturation();
  void set_has_snake();
  inline bool has_effect() const;
  inline void clear_has_effect();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 7,
                                   7, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EffectProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::kivsee::proto::render::v1::EffectConfig* PROTOBUF_NULLABLE effect_config_;
    union EffectUnion {
      constexpr EffectUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE const_color_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE rainbow_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE brightness_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE hue_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE saturation_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE snake_;
    } effect_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kivsee_2fproto_2frender_2fv1_2feffects_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EffectProto_class_data_;
// -------------------------------------------------------------------

class AnimationProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kivsee.proto.render.v1.AnimationProto) */ {
 public:
  inline AnimationProto() : AnimationProto(nullptr) {}
  ~AnimationProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AnimationProto* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AnimationProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AnimationProto(::google::protobuf::internal::ConstantInitialized);

  inline AnimationProto(const AnimationProto& from) : AnimationProto(nullptr, from) {}
  inline AnimationProto(AnimationProto&& from) noexcept
      : AnimationProto(nullptr, ::std::move(from)) {}
  inline AnimationProto& operator=(const AnimationProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnimationProto& operator=(AnimationProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnimationProto& default_instance() {
    return *reinterpret_cast<const AnimationProto*>(
        &_AnimationProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(AnimationProto& a, AnimationProto& b) { a.Swap(&b); }
  inline void Swap(AnimationProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnimationProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnimationProto* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AnimationProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AnimationProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AnimationProto& from) { AnimationProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AnimationProto* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kivsee.proto.render.v1.AnimationProto"; }

 protected:
  explicit AnimationProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  AnimationProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const AnimationProto& from);
  AnimationProto(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, AnimationProto&& from) noexcept
      : AnimationProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEffectsFieldNumber = 1,
    kDurationMsFieldNumber = 2,
    kNumRepeatsFieldNumber = 3,
  };
  // repeated .kivsee.proto.render.v1.EffectProto effects = 1 [json_name = "effects"];
  int effects_size() const;
  private:
  int _internal_effects_size() const;

  public:
  void clear_effects() ;
  ::kivsee::proto::render::v1::EffectProto* PROTOBUF_NONNULL mutable_effects(int index);
  ::google::protobuf::RepeatedPtrField<::kivsee::proto::render::v1::EffectProto>* PROTOBUF_NONNULL mutable_effects();

  private:
  const ::google::protobuf::RepeatedPtrField<::kivsee::proto::render::v1::EffectProto>& _internal_effects() const;
  ::google::protobuf::RepeatedPtrField<::kivsee::proto::render::v1::EffectProto>* PROTOBUF_NONNULL _internal_mutable_effects();
  public:
  const ::kivsee::proto::render::v1::EffectProto& effects(int index) const;
  ::kivsee::proto::render::v1::EffectProto* PROTOBUF_NONNULL add_effects();
  const ::google::protobuf::RepeatedPtrField<::kivsee::proto::render::v1::EffectProto>& effects() const;
  // uint32 duration_ms = 2 [json_name = "durationMs"];
  void clear_duration_ms() ;
  ::uint32_t duration_ms() const;
  void set_duration_ms(::uint32_t value);

  private:
  ::uint32_t _internal_duration_ms() const;
  void _internal_set_duration_ms(::uint32_t value);

  public:
  // uint32 num_repeats = 3 [json_name = "numRepeats"];
  void clear_num_repeats() ;
  ::uint32_t num_repeats() const;
  void set_num_repeats(::uint32_t value);

  private:
  ::uint32_t _internal_num_repeats() const;
  void _internal_set_num_repeats(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:kivsee.proto.render.v1.AnimationProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const AnimationProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::kivsee::proto::render::v1::EffectProto > effects_;
    ::uint32_t duration_ms_;
    ::uint32_t num_repeats_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kivsee_2fproto_2frender_2fv1_2feffects_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull AnimationProto_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// HSV

// float hue = 1 [json_name = "hue"];
inline void HSV::clear_hue() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float HSV::hue() const {
  // @@protoc_insertion_point(field_get:kivsee.proto.render.v1.HSV.hue)
  return _internal_hue();
}
inline void HSV::set_hue(float value) {
  _internal_set_hue(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:kivsee.proto.render.v1.HSV.hue)
}
inline float HSV::_internal_hue() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hue_;
}
inline void HSV::_internal_set_hue(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hue_ = value;
}

// float sat = 2 [json_name = "sat"];
inline void HSV::clear_sat() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sat_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float HSV::sat() const {
  // @@protoc_insertion_point(field_get:kivsee.proto.render.v1.HSV.sat)
  return _internal_sat();
}
inline void HSV::set_sat(float value) {
  _internal_set_sat(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:kivsee.proto.render.v1.HSV.sat)
}
inline float HSV::_internal_sat() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sat_;
}
inline void HSV::_internal_set_sat(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sat_ = value;
}

// float val = 3 [json_name = "val"];
inline void HSV::clear_val() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.val_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float HSV::val() const {
  // @@protoc_insertion_point(field_get:kivsee.proto.render.v1.HSV.val)
  return _internal_val();
}
inline void HSV::set_val(float value) {
  _internal_set_val(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:kivsee.proto.render.v1.HSV.val)
}
inline float HSV::_internal_val() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.val_;
}
inline void HSV::_internal_set_val(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.val_ = value;
}

// -------------------------------------------------------------------

// ConstColorEffectConfig

// .kivsee.proto.render.v1.HSV color = 1 [json_name = "color"];
inline bool ConstColorEffectConfig::has_color() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.color_ != nullptr);
  return value;
}
inline void ConstColorEffectConfig::clear_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.color_ != nullptr) _impl_.color_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kivsee::proto::render::v1::HSV& ConstColorEffectConfig::_internal_color() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kivsee::proto::render::v1::HSV* p = _impl_.color_;
  return p != nullptr ? *p : reinterpret_cast<const ::kivsee::proto::render::v1::HSV&>(::kivsee::proto::render::v1::_HSV_default_instance_);
}
inline const ::kivsee::proto::render::v1::HSV& ConstColorEffectConfig::color() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kivsee.proto.render.v1.ConstColorEffectConfig.color)
  return _internal_color();
}
inline void ConstColorEffectConfig::unsafe_arena_set_allocated_color(
    ::kivsee::proto::render::v1::HSV* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.color_);
  }
  _impl_.color_ = reinterpret_cast<::kivsee::proto::render::v1::HSV*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kivsee.proto.render.v1.ConstColorEffectConfig.color)
}
inline ::kivsee::proto::render::v1::HSV* PROTOBUF_NULLABLE ConstColorEffectConfig::release_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kivsee::proto::render::v1::HSV* released = _impl_.color_;
  _impl_.color_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kivsee::proto::render::v1::HSV* PROTOBUF_NULLABLE ConstColorEffectConfig::unsafe_arena_release_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kivsee.proto.render.v1.ConstColorEffectConfig.color)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kivsee::proto::render::v1::HSV* temp = _impl_.color_;
  _impl_.color_ = nullptr;
  return temp;
}
inline ::kivsee::proto::render::v1::HSV* PROTOBUF_NONNULL ConstColorEffectConfig::_internal_mutable_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.color_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kivsee::proto::render::v1::HSV>(GetArena());
    _impl_.color_ = reinterpret_cast<::kivsee::proto::render::v1::HSV*>(p);
  }
  return _impl_.color_;
}
inline ::kivsee::proto::render::v1::HSV* PROTOBUF_NONNULL ConstColorEffectConfig::mutable_color()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kivsee::proto::render::v1::HSV* _msg = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:kivsee.proto.render.v1.ConstColorEffectConfig.color)
  return _msg;
}
inline void ConstColorEffectConfig::set_allocated_color(::kivsee::proto::render::v1::HSV* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.color_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.color_ = reinterpret_cast<::kivsee::proto::render::v1::HSV*>(value);
  // @@protoc_insertion_point(field_set_allocated:kivsee.proto.render.v1.ConstColorEffectConfig.color)
}

// -------------------------------------------------------------------

// RainbowEffectConfig

// .kivsee.proto.render.v1.FloatFunction hue_start = 1 [json_name = "hueStart"];
inline bool RainbowEffectConfig::has_hue_start() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.hue_start_ != nullptr);
  return value;
}
inline const ::kivsee::proto::render::v1::FloatFunction& RainbowEffectConfig::_internal_hue_start() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kivsee::proto::render::v1::FloatFunction* p = _impl_.hue_start_;
  return p != nullptr ? *p : reinterpret_cast<const ::kivsee::proto::render::v1::FloatFunction&>(::kivsee::proto::render::v1::_FloatFunction_default_instance_);
}
inline const ::kivsee::proto::render::v1::FloatFunction& RainbowEffectConfig::hue_start() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kivsee.proto.render.v1.RainbowEffectConfig.hue_start)
  return _internal_hue_start();
}
inline void RainbowEffectConfig::unsafe_arena_set_allocated_hue_start(
    ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hue_start_);
  }
  _impl_.hue_start_ = reinterpret_cast<::kivsee::proto::render::v1::FloatFunction*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kivsee.proto.render.v1.RainbowEffectConfig.hue_start)
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE RainbowEffectConfig::release_hue_start() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kivsee::proto::render::v1::FloatFunction* released = _impl_.hue_start_;
  _impl_.hue_start_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE RainbowEffectConfig::unsafe_arena_release_hue_start() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kivsee.proto.render.v1.RainbowEffectConfig.hue_start)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kivsee::proto::render::v1::FloatFunction* temp = _impl_.hue_start_;
  _impl_.hue_start_ = nullptr;
  return temp;
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL RainbowEffectConfig::_internal_mutable_hue_start() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hue_start_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kivsee::proto::render::v1::FloatFunction>(GetArena());
    _impl_.hue_start_ = reinterpret_cast<::kivsee::proto::render::v1::FloatFunction*>(p);
  }
  return _impl_.hue_start_;
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL RainbowEffectConfig::mutable_hue_start()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kivsee::proto::render::v1::FloatFunction* _msg = _internal_mutable_hue_start();
  // @@protoc_insertion_point(field_mutable:kivsee.proto.render.v1.RainbowEffectConfig.hue_start)
  return _msg;
}
inline void RainbowEffectConfig::set_allocated_hue_start(::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hue_start_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.hue_start_ = reinterpret_cast<::kivsee::proto::render::v1::FloatFunction*>(value);
  // @@protoc_insertion_point(field_set_allocated:kivsee.proto.render.v1.RainbowEffectConfig.hue_start)
}

// .kivsee.proto.render.v1.FloatFunction hue_end = 2 [json_name = "hueEnd"];
inline bool RainbowEffectConfig::has_hue_end() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.hue_end_ != nullptr);
  return value;
}
inline const ::kivsee::proto::render::v1::FloatFunction& RainbowEffectConfig::_internal_hue_end() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kivsee::proto::render::v1::FloatFunction* p = _impl_.hue_end_;
  return p != nullptr ? *p : reinterpret_cast<const ::kivsee::proto::render::v1::FloatFunction&>(::kivsee::proto::render::v1::_FloatFunction_default_instance_);
}
inline const ::kivsee::proto::render::v1::FloatFunction& RainbowEffectConfig::hue_end() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kivsee.proto.render.v1.RainbowEffectConfig.hue_end)
  return _internal_hue_end();
}
inline void RainbowEffectConfig::unsafe_arena_set_allocated_hue_end(
    ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hue_end_);
  }
  _impl_.hue_end_ = reinterpret_cast<::kivsee::proto::render::v1::FloatFunction*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kivsee.proto.render.v1.RainbowEffectConfig.hue_end)
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE RainbowEffectConfig::release_hue_end() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kivsee::proto::render::v1::FloatFunction* released = _impl_.hue_end_;
  _impl_.hue_end_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE RainbowEffectConfig::unsafe_arena_release_hue_end() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kivsee.proto.render.v1.RainbowEffectConfig.hue_end)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kivsee::proto::render::v1::FloatFunction* temp = _impl_.hue_end_;
  _impl_.hue_end_ = nullptr;
  return temp;
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL RainbowEffectConfig::_internal_mutable_hue_end() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hue_end_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kivsee::proto::render::v1::FloatFunction>(GetArena());
    _impl_.hue_end_ = reinterpret_cast<::kivsee::proto::render::v1::FloatFunction*>(p);
  }
  return _impl_.hue_end_;
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL RainbowEffectConfig::mutable_hue_end()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::kivsee::proto::render::v1::FloatFunction* _msg = _internal_mutable_hue_end();
  // @@protoc_insertion_point(field_mutable:kivsee.proto.render.v1.RainbowEffectConfig.hue_end)
  return _msg;
}
inline void RainbowEffectConfig::set_allocated_hue_end(::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hue_end_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.hue_end_ = reinterpret_cast<::kivsee::proto::render::v1::FloatFunction*>(value);
  // @@protoc_insertion_point(field_set_allocated:kivsee.proto.render.v1.RainbowEffectConfig.hue_end)
}

// -------------------------------------------------------------------

// BrightnessEffectConfig

// .kivsee.proto.render.v1.FloatFunction mult_factor = 1 [json_name = "multFactor"];
inline bool BrightnessEffectConfig::has_mult_factor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.mult_factor_ != nullptr);
  return value;
}
inline const ::kivsee::proto::render::v1::FloatFunction& BrightnessEffectConfig::_internal_mult_factor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kivsee::proto::render::v1::FloatFunction* p = _impl_.mult_factor_;
  return p != nullptr ? *p : reinterpret_cast<const ::kivsee::proto::render::v1::FloatFunction&>(::kivsee::proto::render::v1::_FloatFunction_default_instance_);
}
inline const ::kivsee::proto::render::v1::FloatFunction& BrightnessEffectConfig::mult_factor() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kivsee.proto.render.v1.BrightnessEffectConfig.mult_factor)
  return _internal_mult_factor();
}
inline void BrightnessEffectConfig::unsafe_arena_set_allocated_mult_factor(
    ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.mult_factor_);
  }
  _impl_.mult_factor_ = reinterpret_cast<::kivsee::proto::render::v1::FloatFunction*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kivsee.proto.render.v1.BrightnessEffectConfig.mult_factor)
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE BrightnessEffectConfig::release_mult_factor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kivsee::proto::render::v1::FloatFunction* released = _impl_.mult_factor_;
  _impl_.mult_factor_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE BrightnessEffectConfig::unsafe_arena_release_mult_factor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kivsee.proto.render.v1.BrightnessEffectConfig.mult_factor)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kivsee::proto::render::v1::FloatFunction* temp = _impl_.mult_factor_;
  _impl_.mult_factor_ = nullptr;
  return temp;
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL BrightnessEffectConfig::_internal_mutable_mult_factor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.mult_factor_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kivsee::proto::render::v1::FloatFunction>(GetArena());
    _impl_.mult_factor_ = reinterpret_cast<::kivsee::proto::render::v1::FloatFunction*>(p);
  }
  return _impl_.mult_factor_;
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL BrightnessEffectConfig::mutable_mult_factor()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kivsee::proto::render::v1::FloatFunction* _msg = _internal_mutable_mult_factor();
  // @@protoc_insertion_point(field_mutable:kivsee.proto.render.v1.BrightnessEffectConfig.mult_factor)
  return _msg;
}
inline void BrightnessEffectConfig::set_allocated_mult_factor(::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.mult_factor_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.mult_factor_ = reinterpret_cast<::kivsee::proto::render::v1::FloatFunction*>(value);
  // @@protoc_insertion_point(field_set_allocated:kivsee.proto.render.v1.BrightnessEffectConfig.mult_factor)
}

// -------------------------------------------------------------------

// HueEffectConfig

// .kivsee.proto.render.v1.FloatFunction offset_factor = 1 [json_name = "offsetFactor"];
inline bool HueEffectConfig::has_offset_factor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.offset_factor_ != nullptr);
  return value;
}
inline const ::kivsee::proto::render::v1::FloatFunction& HueEffectConfig::_internal_offset_factor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kivsee::proto::render::v1::FloatFunction* p = _impl_.offset_factor_;
  return p != nullptr ? *p : reinterpret_cast<const ::kivsee::proto::render::v1::FloatFunction&>(::kivsee::proto::render::v1::_FloatFunction_default_instance_);
}
inline const ::kivsee::proto::render::v1::FloatFunction& HueEffectConfig::offset_factor() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kivsee.proto.render.v1.HueEffectConfig.offset_factor)
  return _internal_offset_factor();
}
inline void HueEffectConfig::unsafe_arena_set_allocated_offset_factor(
    ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.offset_factor_);
  }
  _impl_.offset_factor_ = reinterpret_cast<::kivsee::proto::render::v1::FloatFunction*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kivsee.proto.render.v1.HueEffectConfig.offset_factor)
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE HueEffectConfig::release_offset_factor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kivsee::proto::render::v1::FloatFunction* released = _impl_.offset_factor_;
  _impl_.offset_factor_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE HueEffectConfig::unsafe_arena_release_offset_factor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kivsee.proto.render.v1.HueEffectConfig.offset_factor)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kivsee::proto::render::v1::FloatFunction* temp = _impl_.offset_factor_;
  _impl_.offset_factor_ = nullptr;
  return temp;
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL HueEffectConfig::_internal_mutable_offset_factor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.offset_factor_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kivsee::proto::render::v1::FloatFunction>(GetArena());
    _impl_.offset_factor_ = reinterpret_cast<::kivsee::proto::render::v1::FloatFunction*>(p);
  }
  return _impl_.offset_factor_;
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL HueEffectConfig::mutable_offset_factor()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kivsee::proto::render::v1::FloatFunction* _msg = _internal_mutable_offset_factor();
  // @@protoc_insertion_point(field_mutable:kivsee.proto.render.v1.HueEffectConfig.offset_factor)
  return _msg;
}
inline void HueEffectConfig::set_allocated_offset_factor(::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.offset_factor_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.offset_factor_ = reinterpret_cast<::kivsee::proto::render::v1::FloatFunction*>(value);
  // @@protoc_insertion_point(field_set_allocated:kivsee.proto.render.v1.HueEffectConfig.offset_factor)
}

// -------------------------------------------------------------------

// SaturationEffectConfig

// .kivsee.proto.render.v1.FloatFunction mult_factor = 1 [json_name = "multFactor"];
inline bool SaturationEffectConfig::has_mult_factor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.mult_factor_ != nullptr);
  return value;
}
inline const ::kivsee::proto::render::v1::FloatFunction& SaturationEffectConfig::_internal_mult_factor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kivsee::proto::render::v1::FloatFunction* p = _impl_.mult_factor_;
  return p != nullptr ? *p : reinterpret_cast<const ::kivsee::proto::render::v1::FloatFunction&>(::kivsee::proto::render::v1::_FloatFunction_default_instance_);
}
inline const ::kivsee::proto::render::v1::FloatFunction& SaturationEffectConfig::mult_factor() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kivsee.proto.render.v1.SaturationEffectConfig.mult_factor)
  return _internal_mult_factor();
}
inline void SaturationEffectConfig::unsafe_arena_set_allocated_mult_factor(
    ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.mult_factor_);
  }
  _impl_.mult_factor_ = reinterpret_cast<::kivsee::proto::render::v1::FloatFunction*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kivsee.proto.render.v1.SaturationEffectConfig.mult_factor)
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE SaturationEffectConfig::release_mult_factor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kivsee::proto::render::v1::FloatFunction* released = _impl_.mult_factor_;
  _impl_.mult_factor_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE SaturationEffectConfig::unsafe_arena_release_mult_factor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kivsee.proto.render.v1.SaturationEffectConfig.mult_factor)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kivsee::proto::render::v1::FloatFunction* temp = _impl_.mult_factor_;
  _impl_.mult_factor_ = nullptr;
  return temp;
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL SaturationEffectConfig::_internal_mutable_mult_factor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.mult_factor_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kivsee::proto::render::v1::FloatFunction>(GetArena());
    _impl_.mult_factor_ = reinterpret_cast<::kivsee::proto::render::v1::FloatFunction*>(p);
  }
  return _impl_.mult_factor_;
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL SaturationEffectConfig::mutable_mult_factor()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kivsee::proto::render::v1::FloatFunction* _msg = _internal_mutable_mult_factor();
  // @@protoc_insertion_point(field_mutable:kivsee.proto.render.v1.SaturationEffectConfig.mult_factor)
  return _msg;
}
inline void SaturationEffectConfig::set_allocated_mult_factor(::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.mult_factor_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.mult_factor_ = reinterpret_cast<::kivsee::proto::render::v1::FloatFunction*>(value);
  // @@protoc_insertion_point(field_set_allocated:kivsee.proto.render.v1.SaturationEffectConfig.mult_factor)
}

// -------------------------------------------------------------------

// SnakeEffectConfig

// .kivsee.proto.render.v1.FloatFunction head = 1 [json_name = "head"];
inline bool SnakeEffectConfig::has_head() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.head_ != nullptr);
  return value;
}
inline const ::kivsee::proto::render::v1::FloatFunction& SnakeEffectConfig::_internal_head() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kivsee::proto::render::v1::FloatFunction* p = _impl_.head_;
  return p != nullptr ? *p : reinterpret_cast<const ::kivsee::proto::render::v1::FloatFunction&>(::kivsee::proto::render::v1::_FloatFunction_default_instance_);
}
inline const ::kivsee::proto::render::v1::FloatFunction& SnakeEffectConfig::head() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kivsee.proto.render.v1.SnakeEffectConfig.head)
  return _internal_head();
}
inline void SnakeEffectConfig::unsafe_arena_set_allocated_head(
    ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.head_);
  }
  _impl_.head_ = reinterpret_cast<::kivsee::proto::render::v1::FloatFunction*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kivsee.proto.render.v1.SnakeEffectConfig.head)
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE SnakeEffectConfig::release_head() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kivsee::proto::render::v1::FloatFunction* released = _impl_.head_;
  _impl_.head_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE SnakeEffectConfig::unsafe_arena_release_head() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kivsee.proto.render.v1.SnakeEffectConfig.head)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kivsee::proto::render::v1::FloatFunction* temp = _impl_.head_;
  _impl_.head_ = nullptr;
  return temp;
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL SnakeEffectConfig::_internal_mutable_head() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.head_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kivsee::proto::render::v1::FloatFunction>(GetArena());
    _impl_.head_ = reinterpret_cast<::kivsee::proto::render::v1::FloatFunction*>(p);
  }
  return _impl_.head_;
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL SnakeEffectConfig::mutable_head()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kivsee::proto::render::v1::FloatFunction* _msg = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:kivsee.proto.render.v1.SnakeEffectConfig.head)
  return _msg;
}
inline void SnakeEffectConfig::set_allocated_head(::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.head_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.head_ = reinterpret_cast<::kivsee::proto::render::v1::FloatFunction*>(value);
  // @@protoc_insertion_point(field_set_allocated:kivsee.proto.render.v1.SnakeEffectConfig.head)
}

// .kivsee.proto.render.v1.FloatFunction tail_length = 2 [json_name = "tailLength"];
inline bool SnakeEffectConfig::has_tail_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tail_length_ != nullptr);
  return value;
}
inline const ::kivsee::proto::render::v1::FloatFunction& SnakeEffectConfig::_internal_tail_length() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kivsee::proto::render::v1::FloatFunction* p = _impl_.tail_length_;
  return p != nullptr ? *p : reinterpret_cast<const ::kivsee::proto::render::v1::FloatFunction&>(::kivsee::proto::render::v1::_FloatFunction_default_instance_);
}
inline const ::kivsee::proto::render::v1::FloatFunction& SnakeEffectConfig::tail_length() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kivsee.proto.render.v1.SnakeEffectConfig.tail_length)
  return _internal_tail_length();
}
inline void SnakeEffectConfig::unsafe_arena_set_allocated_tail_length(
    ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tail_length_);
  }
  _impl_.tail_length_ = reinterpret_cast<::kivsee::proto::render::v1::FloatFunction*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kivsee.proto.render.v1.SnakeEffectConfig.tail_length)
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE SnakeEffectConfig::release_tail_length() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kivsee::proto::render::v1::FloatFunction* released = _impl_.tail_length_;
  _impl_.tail_length_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE SnakeEffectConfig::unsafe_arena_release_tail_length() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kivsee.proto.render.v1.SnakeEffectConfig.tail_length)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kivsee::proto::render::v1::FloatFunction* temp = _impl_.tail_length_;
  _impl_.tail_length_ = nullptr;
  return temp;
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL SnakeEffectConfig::_internal_mutable_tail_length() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tail_length_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kivsee::proto::render::v1::FloatFunction>(GetArena());
    _impl_.tail_length_ = reinterpret_cast<::kivsee::proto::render::v1::FloatFunction*>(p);
  }
  return _impl_.tail_length_;
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL SnakeEffectConfig::mutable_tail_length()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::kivsee::proto::render::v1::FloatFunction* _msg = _internal_mutable_tail_length();
  // @@protoc_insertion_point(field_mutable:kivsee.proto.render.v1.SnakeEffectConfig.tail_length)
  return _msg;
}
inline void SnakeEffectConfig::set_allocated_tail_length(::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tail_length_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.tail_length_ = reinterpret_cast<::kivsee::proto::render::v1::FloatFunction*>(value);
  // @@protoc_insertion_point(field_set_allocated:kivsee.proto.render.v1.SnakeEffectConfig.tail_length)
}

// bool cyclic = 3 [json_name = "cyclic"];
inline void SnakeEffectConfig::clear_cyclic() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cyclic_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool SnakeEffectConfig::cyclic() const {
  // @@protoc_insertion_point(field_get:kivsee.proto.render.v1.SnakeEffectConfig.cyclic)
  return _internal_cyclic();
}
inline void SnakeEffectConfig::set_cyclic(bool value) {
  _internal_set_cyclic(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:kivsee.proto.render.v1.SnakeEffectConfig.cyclic)
}
inline bool SnakeEffectConfig::_internal_cyclic() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cyclic_;
}
inline void SnakeEffectConfig::_internal_set_cyclic(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cyclic_ = value;
}

// -------------------------------------------------------------------

// SegmentEffectConfig

// .kivsee.proto.render.v1.FloatFunction start = 1 [json_name = "start"];
inline bool SegmentEffectConfig::has_start() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.start_ != nullptr);
  return value;
}
inline const ::kivsee::proto::render::v1::FloatFunction& SegmentEffectConfig::_internal_start() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kivsee::proto::render::v1::FloatFunction* p = _impl_.start_;
  return p != nullptr ? *p : reinterpret_cast<const ::kivsee::proto::render::v1::FloatFunction&>(::kivsee::proto::render::v1::_FloatFunction_default_instance_);
}
inline const ::kivsee::proto::render::v1::FloatFunction& SegmentEffectConfig::start() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kivsee.proto.render.v1.SegmentEffectConfig.start)
  return _internal_start();
}
inline void SegmentEffectConfig::unsafe_arena_set_allocated_start(
    ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.start_);
  }
  _impl_.start_ = reinterpret_cast<::kivsee::proto::render::v1::FloatFunction*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kivsee.proto.render.v1.SegmentEffectConfig.start)
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE SegmentEffectConfig::release_start() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kivsee::proto::render::v1::FloatFunction* released = _impl_.start_;
  _impl_.start_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE SegmentEffectConfig::unsafe_arena_release_start() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kivsee.proto.render.v1.SegmentEffectConfig.start)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kivsee::proto::render::v1::FloatFunction* temp = _impl_.start_;
  _impl_.start_ = nullptr;
  return temp;
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL SegmentEffectConfig::_internal_mutable_start() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.start_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kivsee::proto::render::v1::FloatFunction>(GetArena());
    _impl_.start_ = reinterpret_cast<::kivsee::proto::render::v1::FloatFunction*>(p);
  }
  return _impl_.start_;
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL SegmentEffectConfig::mutable_start()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kivsee::proto::render::v1::FloatFunction* _msg = _internal_mutable_start();
  // @@protoc_insertion_point(field_mutable:kivsee.proto.render.v1.SegmentEffectConfig.start)
  return _msg;
}
inline void SegmentEffectConfig::set_allocated_start(::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.start_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.start_ = reinterpret_cast<::kivsee::proto::render::v1::FloatFunction*>(value);
  // @@protoc_insertion_point(field_set_allocated:kivsee.proto.render.v1.SegmentEffectConfig.start)
}

// .kivsee.proto.render.v1.FloatFunction end = 2 [json_name = "end"];
inline bool SegmentEffectConfig::has_end() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.end_ != nullptr);
  return value;
}
inline const ::kivsee::proto::render::v1::FloatFunction& SegmentEffectConfig::_internal_end() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kivsee::proto::render::v1::FloatFunction* p = _impl_.end_;
  return p != nullptr ? *p : reinterpret_cast<const ::kivsee::proto::render::v1::FloatFunction&>(::kivsee::proto::render::v1::_FloatFunction_default_instance_);
}
inline const ::kivsee::proto::render::v1::FloatFunction& SegmentEffectConfig::end() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kivsee.proto.render.v1.SegmentEffectConfig.end)
  return _internal_end();
}
inline void SegmentEffectConfig::unsafe_arena_set_allocated_end(
    ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.end_);
  }
  _impl_.end_ = reinterpret_cast<::kivsee::proto::render::v1::FloatFunction*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kivsee.proto.render.v1.SegmentEffectConfig.end)
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE SegmentEffectConfig::release_end() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kivsee::proto::render::v1::FloatFunction* released = _impl_.end_;
  _impl_.end_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE SegmentEffectConfig::unsafe_arena_release_end() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kivsee.proto.render.v1.SegmentEffectConfig.end)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kivsee::proto::render::v1::FloatFunction* temp = _impl_.end_;
  _impl_.end_ = nullptr;
  return temp;
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL SegmentEffectConfig::_internal_mutable_end() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.end_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kivsee::proto::render::v1::FloatFunction>(GetArena());
    _impl_.end_ = reinterpret_cast<::kivsee::proto::render::v1::FloatFunction*>(p);
  }
  return _impl_.end_;
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL SegmentEffectConfig::mutable_end()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::kivsee::proto::render::v1::FloatFunction* _msg = _internal_mutable_end();
  // @@protoc_insertion_point(field_mutable:kivsee.proto.render.v1.SegmentEffectConfig.end)
  return _msg;
}
inline void SegmentEffectConfig::set_allocated_end(::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.end_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.end_ = reinterpret_cast<::kivsee::proto::render::v1::FloatFunction*>(value);
  // @@protoc_insertion_point(field_set_allocated:kivsee.proto.render.v1.SegmentEffectConfig.end)
}

// -------------------------------------------------------------------

// GlitterEffectConfig

// .kivsee.proto.render.v1.FloatFunction intensity = 1 [json_name = "intensity"];
inline bool GlitterEffectConfig::has_intensity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.intensity_ != nullptr);
  return value;
}
inline const ::kivsee::proto::render::v1::FloatFunction& GlitterEffectConfig::_internal_intensity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kivsee::proto::render::v1::FloatFunction* p = _impl_.intensity_;
  return p != nullptr ? *p : reinterpret_cast<const ::kivsee::proto::render::v1::FloatFunction&>(::kivsee::proto::render::v1::_FloatFunction_default_instance_);
}
inline const ::kivsee::proto::render::v1::FloatFunction& GlitterEffectConfig::intensity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kivsee.proto.render.v1.GlitterEffectConfig.intensity)
  return _internal_intensity();
}
inline void GlitterEffectConfig::unsafe_arena_set_allocated_intensity(
    ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.intensity_);
  }
  _impl_.intensity_ = reinterpret_cast<::kivsee::proto::render::v1::FloatFunction*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kivsee.proto.render.v1.GlitterEffectConfig.intensity)
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE GlitterEffectConfig::release_intensity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kivsee::proto::render::v1::FloatFunction* released = _impl_.intensity_;
  _impl_.intensity_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE GlitterEffectConfig::unsafe_arena_release_intensity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kivsee.proto.render.v1.GlitterEffectConfig.intensity)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kivsee::proto::render::v1::FloatFunction* temp = _impl_.intensity_;
  _impl_.intensity_ = nullptr;
  return temp;
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL GlitterEffectConfig::_internal_mutable_intensity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.intensity_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kivsee::proto::render::v1::FloatFunction>(GetArena());
    _impl_.intensity_ = reinterpret_cast<::kivsee::proto::render::v1::FloatFunction*>(p);
  }
  return _impl_.intensity_;
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL GlitterEffectConfig::mutable_intensity()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kivsee::proto::render::v1::FloatFunction* _msg = _internal_mutable_intensity();
  // @@protoc_insertion_point(field_mutable:kivsee.proto.render.v1.GlitterEffectConfig.intensity)
  return _msg;
}
inline void GlitterEffectConfig::set_allocated_intensity(::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.intensity_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.intensity_ = reinterpret_cast<::kivsee::proto::render::v1::FloatFunction*>(value);
  // @@protoc_insertion_point(field_set_allocated:kivsee.proto.render.v1.GlitterEffectConfig.intensity)
}

// .kivsee.proto.render.v1.FloatFunction sat_mult_factor = 2 [json_name = "satMultFactor"];
inline bool GlitterEffectConfig::has_sat_mult_factor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sat_mult_factor_ != nullptr);
  return value;
}
inline const ::kivsee::proto::render::v1::FloatFunction& GlitterEffectConfig::_internal_sat_mult_factor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kivsee::proto::render::v1::FloatFunction* p = _impl_.sat_mult_factor_;
  return p != nullptr ? *p : reinterpret_cast<const ::kivsee::proto::render::v1::FloatFunction&>(::kivsee::proto::render::v1::_FloatFunction_default_instance_);
}
inline const ::kivsee::proto::render::v1::FloatFunction& GlitterEffectConfig::sat_mult_factor() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kivsee.proto.render.v1.GlitterEffectConfig.sat_mult_factor)
  return _internal_sat_mult_factor();
}
inline void GlitterEffectConfig::unsafe_arena_set_allocated_sat_mult_factor(
    ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sat_mult_factor_);
  }
  _impl_.sat_mult_factor_ = reinterpret_cast<::kivsee::proto::render::v1::FloatFunction*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kivsee.proto.render.v1.GlitterEffectConfig.sat_mult_factor)
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE GlitterEffectConfig::release_sat_mult_factor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kivsee::proto::render::v1::FloatFunction* released = _impl_.sat_mult_factor_;
  _impl_.sat_mult_factor_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE GlitterEffectConfig::unsafe_arena_release_sat_mult_factor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kivsee.proto.render.v1.GlitterEffectConfig.sat_mult_factor)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kivsee::proto::render::v1::FloatFunction* temp = _impl_.sat_mult_factor_;
  _impl_.sat_mult_factor_ = nullptr;
  return temp;
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL GlitterEffectConfig::_internal_mutable_sat_mult_factor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.sat_mult_factor_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kivsee::proto::render::v1::FloatFunction>(GetArena());
    _impl_.sat_mult_factor_ = reinterpret_cast<::kivsee::proto::render::v1::FloatFunction*>(p);
  }
  return _impl_.sat_mult_factor_;
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL GlitterEffectConfig::mutable_sat_mult_factor()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::kivsee::proto::render::v1::FloatFunction* _msg = _internal_mutable_sat_mult_factor();
  // @@protoc_insertion_point(field_mutable:kivsee.proto.render.v1.GlitterEffectConfig.sat_mult_factor)
  return _msg;
}
inline void GlitterEffectConfig::set_allocated_sat_mult_factor(::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sat_mult_factor_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.sat_mult_factor_ = reinterpret_cast<::kivsee::proto::render::v1::FloatFunction*>(value);
  // @@protoc_insertion_point(field_set_allocated:kivsee.proto.render.v1.GlitterEffectConfig.sat_mult_factor)
}

// -------------------------------------------------------------------

// AlternateEffectConfig

// uint32 numberOfPixels = 1 [json_name = "numberOfPixels"];
inline void AlternateEffectConfig::clear_numberofpixels() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.numberofpixels_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t AlternateEffectConfig::numberofpixels() const {
  // @@protoc_insertion_point(field_get:kivsee.proto.render.v1.AlternateEffectConfig.numberOfPixels)
  return _internal_numberofpixels();
}
inline void AlternateEffectConfig::set_numberofpixels(::uint32_t value) {
  _internal_set_numberofpixels(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:kivsee.proto.render.v1.AlternateEffectConfig.numberOfPixels)
}
inline ::uint32_t AlternateEffectConfig::_internal_numberofpixels() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.numberofpixels_;
}
inline void AlternateEffectConfig::_internal_set_numberofpixels(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.numberofpixels_ = value;
}

// .kivsee.proto.render.v1.FloatFunction hue_offset = 2 [json_name = "hueOffset"];
inline bool AlternateEffectConfig::has_hue_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.hue_offset_ != nullptr);
  return value;
}
inline const ::kivsee::proto::render::v1::FloatFunction& AlternateEffectConfig::_internal_hue_offset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kivsee::proto::render::v1::FloatFunction* p = _impl_.hue_offset_;
  return p != nullptr ? *p : reinterpret_cast<const ::kivsee::proto::render::v1::FloatFunction&>(::kivsee::proto::render::v1::_FloatFunction_default_instance_);
}
inline const ::kivsee::proto::render::v1::FloatFunction& AlternateEffectConfig::hue_offset() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kivsee.proto.render.v1.AlternateEffectConfig.hue_offset)
  return _internal_hue_offset();
}
inline void AlternateEffectConfig::unsafe_arena_set_allocated_hue_offset(
    ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hue_offset_);
  }
  _impl_.hue_offset_ = reinterpret_cast<::kivsee::proto::render::v1::FloatFunction*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kivsee.proto.render.v1.AlternateEffectConfig.hue_offset)
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE AlternateEffectConfig::release_hue_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kivsee::proto::render::v1::FloatFunction* released = _impl_.hue_offset_;
  _impl_.hue_offset_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE AlternateEffectConfig::unsafe_arena_release_hue_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kivsee.proto.render.v1.AlternateEffectConfig.hue_offset)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kivsee::proto::render::v1::FloatFunction* temp = _impl_.hue_offset_;
  _impl_.hue_offset_ = nullptr;
  return temp;
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL AlternateEffectConfig::_internal_mutable_hue_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hue_offset_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kivsee::proto::render::v1::FloatFunction>(GetArena());
    _impl_.hue_offset_ = reinterpret_cast<::kivsee::proto::render::v1::FloatFunction*>(p);
  }
  return _impl_.hue_offset_;
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL AlternateEffectConfig::mutable_hue_offset()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kivsee::proto::render::v1::FloatFunction* _msg = _internal_mutable_hue_offset();
  // @@protoc_insertion_point(field_mutable:kivsee.proto.render.v1.AlternateEffectConfig.hue_offset)
  return _msg;
}
inline void AlternateEffectConfig::set_allocated_hue_offset(::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hue_offset_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.hue_offset_ = reinterpret_cast<::kivsee::proto::render::v1::FloatFunction*>(value);
  // @@protoc_insertion_point(field_set_allocated:kivsee.proto.render.v1.AlternateEffectConfig.hue_offset)
}

// .kivsee.proto.render.v1.FloatFunction sat_mult = 3 [json_name = "satMult"];
inline bool AlternateEffectConfig::has_sat_mult() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sat_mult_ != nullptr);
  return value;
}
inline const ::kivsee::proto::render::v1::FloatFunction& AlternateEffectConfig::_internal_sat_mult() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kivsee::proto::render::v1::FloatFunction* p = _impl_.sat_mult_;
  return p != nullptr ? *p : reinterpret_cast<const ::kivsee::proto::render::v1::FloatFunction&>(::kivsee::proto::render::v1::_FloatFunction_default_instance_);
}
inline const ::kivsee::proto::render::v1::FloatFunction& AlternateEffectConfig::sat_mult() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kivsee.proto.render.v1.AlternateEffectConfig.sat_mult)
  return _internal_sat_mult();
}
inline void AlternateEffectConfig::unsafe_arena_set_allocated_sat_mult(
    ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sat_mult_);
  }
  _impl_.sat_mult_ = reinterpret_cast<::kivsee::proto::render::v1::FloatFunction*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kivsee.proto.render.v1.AlternateEffectConfig.sat_mult)
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE AlternateEffectConfig::release_sat_mult() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kivsee::proto::render::v1::FloatFunction* released = _impl_.sat_mult_;
  _impl_.sat_mult_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE AlternateEffectConfig::unsafe_arena_release_sat_mult() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kivsee.proto.render.v1.AlternateEffectConfig.sat_mult)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kivsee::proto::render::v1::FloatFunction* temp = _impl_.sat_mult_;
  _impl_.sat_mult_ = nullptr;
  return temp;
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL AlternateEffectConfig::_internal_mutable_sat_mult() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.sat_mult_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kivsee::proto::render::v1::FloatFunction>(GetArena());
    _impl_.sat_mult_ = reinterpret_cast<::kivsee::proto::render::v1::FloatFunction*>(p);
  }
  return _impl_.sat_mult_;
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL AlternateEffectConfig::mutable_sat_mult()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::kivsee::proto::render::v1::FloatFunction* _msg = _internal_mutable_sat_mult();
  // @@protoc_insertion_point(field_mutable:kivsee.proto.render.v1.AlternateEffectConfig.sat_mult)
  return _msg;
}
inline void AlternateEffectConfig::set_allocated_sat_mult(::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sat_mult_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.sat_mult_ = reinterpret_cast<::kivsee::proto::render::v1::FloatFunction*>(value);
  // @@protoc_insertion_point(field_set_allocated:kivsee.proto.render.v1.AlternateEffectConfig.sat_mult)
}

// .kivsee.proto.render.v1.FloatFunction brightness_mult = 4 [json_name = "brightnessMult"];
inline bool AlternateEffectConfig::has_brightness_mult() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.brightness_mult_ != nullptr);
  return value;
}
inline const ::kivsee::proto::render::v1::FloatFunction& AlternateEffectConfig::_internal_brightness_mult() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kivsee::proto::render::v1::FloatFunction* p = _impl_.brightness_mult_;
  return p != nullptr ? *p : reinterpret_cast<const ::kivsee::proto::render::v1::FloatFunction&>(::kivsee::proto::render::v1::_FloatFunction_default_instance_);
}
inline const ::kivsee::proto::render::v1::FloatFunction& AlternateEffectConfig::brightness_mult() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kivsee.proto.render.v1.AlternateEffectConfig.brightness_mult)
  return _internal_brightness_mult();
}
inline void AlternateEffectConfig::unsafe_arena_set_allocated_brightness_mult(
    ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.brightness_mult_);
  }
  _impl_.brightness_mult_ = reinterpret_cast<::kivsee::proto::render::v1::FloatFunction*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kivsee.proto.render.v1.AlternateEffectConfig.brightness_mult)
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE AlternateEffectConfig::release_brightness_mult() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::kivsee::proto::render::v1::FloatFunction* released = _impl_.brightness_mult_;
  _impl_.brightness_mult_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE AlternateEffectConfig::unsafe_arena_release_brightness_mult() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kivsee.proto.render.v1.AlternateEffectConfig.brightness_mult)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::kivsee::proto::render::v1::FloatFunction* temp = _impl_.brightness_mult_;
  _impl_.brightness_mult_ = nullptr;
  return temp;
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL AlternateEffectConfig::_internal_mutable_brightness_mult() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.brightness_mult_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kivsee::proto::render::v1::FloatFunction>(GetArena());
    _impl_.brightness_mult_ = reinterpret_cast<::kivsee::proto::render::v1::FloatFunction*>(p);
  }
  return _impl_.brightness_mult_;
}
inline ::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NONNULL AlternateEffectConfig::mutable_brightness_mult()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::kivsee::proto::render::v1::FloatFunction* _msg = _internal_mutable_brightness_mult();
  // @@protoc_insertion_point(field_mutable:kivsee.proto.render.v1.AlternateEffectConfig.brightness_mult)
  return _msg;
}
inline void AlternateEffectConfig::set_allocated_brightness_mult(::kivsee::proto::render::v1::FloatFunction* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.brightness_mult_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.brightness_mult_ = reinterpret_cast<::kivsee::proto::render::v1::FloatFunction*>(value);
  // @@protoc_insertion_point(field_set_allocated:kivsee.proto.render.v1.AlternateEffectConfig.brightness_mult)
}

// -------------------------------------------------------------------

// EffectConfig

// uint32 start_time = 1 [json_name = "startTime"];
inline void EffectConfig::clear_start_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.start_time_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t EffectConfig::start_time() const {
  // @@protoc_insertion_point(field_get:kivsee.proto.render.v1.EffectConfig.start_time)
  return _internal_start_time();
}
inline void EffectConfig::set_start_time(::uint32_t value) {
  _internal_set_start_time(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:kivsee.proto.render.v1.EffectConfig.start_time)
}
inline ::uint32_t EffectConfig::_internal_start_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.start_time_;
}
inline void EffectConfig::_internal_set_start_time(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.start_time_ = value;
}

// uint32 end_time = 2 [json_name = "endTime"];
inline void EffectConfig::clear_end_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.end_time_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t EffectConfig::end_time() const {
  // @@protoc_insertion_point(field_get:kivsee.proto.render.v1.EffectConfig.end_time)
  return _internal_end_time();
}
inline void EffectConfig::set_end_time(::uint32_t value) {
  _internal_set_end_time(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:kivsee.proto.render.v1.EffectConfig.end_time)
}
inline ::uint32_t EffectConfig::_internal_end_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.end_time_;
}
inline void EffectConfig::_internal_set_end_time(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.end_time_ = value;
}

// string segments = 3 [json_name = "segments"];
inline void EffectConfig::clear_segments() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.segments_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& EffectConfig::segments() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kivsee.proto.render.v1.EffectConfig.segments)
  return _internal_segments();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void EffectConfig::set_segments(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.segments_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kivsee.proto.render.v1.EffectConfig.segments)
}
inline ::std::string* PROTOBUF_NONNULL EffectConfig::mutable_segments()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_segments();
  // @@protoc_insertion_point(field_mutable:kivsee.proto.render.v1.EffectConfig.segments)
  return _s;
}
inline const ::std::string& EffectConfig::_internal_segments() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.segments_.Get();
}
inline void EffectConfig::_internal_set_segments(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.segments_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL EffectConfig::_internal_mutable_segments() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.segments_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE EffectConfig::release_segments() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kivsee.proto.render.v1.EffectConfig.segments)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.segments_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.segments_.Set("", GetArena());
  }
  return released;
}
inline void EffectConfig::set_allocated_segments(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.segments_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.segments_.IsDefault()) {
    _impl_.segments_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kivsee.proto.render.v1.EffectConfig.segments)
}

// float repeat_num = 4 [json_name = "repeatNum"];
inline void EffectConfig::clear_repeat_num() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.repeat_num_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float EffectConfig::repeat_num() const {
  // @@protoc_insertion_point(field_get:kivsee.proto.render.v1.EffectConfig.repeat_num)
  return _internal_repeat_num();
}
inline void EffectConfig::set_repeat_num(float value) {
  _internal_set_repeat_num(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:kivsee.proto.render.v1.EffectConfig.repeat_num)
}
inline float EffectConfig::_internal_repeat_num() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.repeat_num_;
}
inline void EffectConfig::_internal_set_repeat_num(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.repeat_num_ = value;
}

// float repeat_start = 5 [json_name = "repeatStart"];
inline void EffectConfig::clear_repeat_start() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.repeat_start_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float EffectConfig::repeat_start() const {
  // @@protoc_insertion_point(field_get:kivsee.proto.render.v1.EffectConfig.repeat_start)
  return _internal_repeat_start();
}
inline void EffectConfig::set_repeat_start(float value) {
  _internal_set_repeat_start(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:kivsee.proto.render.v1.EffectConfig.repeat_start)
}
inline float EffectConfig::_internal_repeat_start() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.repeat_start_;
}
inline void EffectConfig::_internal_set_repeat_start(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.repeat_start_ = value;
}

// float repeat_end = 6 [json_name = "repeatEnd"];
inline void EffectConfig::clear_repeat_end() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.repeat_end_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float EffectConfig::repeat_end() const {
  // @@protoc_insertion_point(field_get:kivsee.proto.render.v1.EffectConfig.repeat_end)
  return _internal_repeat_end();
}
inline void EffectConfig::set_repeat_end(float value) {
  _internal_set_repeat_end(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:kivsee.proto.render.v1.EffectConfig.repeat_end)
}
inline float EffectConfig::_internal_repeat_end() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.repeat_end_;
}
inline void EffectConfig::_internal_set_repeat_end(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.repeat_end_ = value;
}

// -------------------------------------------------------------------

// EffectProto

// .kivsee.proto.render.v1.EffectConfig effect_config = 1 [json_name = "effectConfig"];
inline bool EffectProto::has_effect_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.effect_config_ != nullptr);
  return value;
}
inline void EffectProto::clear_effect_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.effect_config_ != nullptr) _impl_.effect_config_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kivsee::proto::render::v1::EffectConfig& EffectProto::_internal_effect_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kivsee::proto::render::v1::EffectConfig* p = _impl_.effect_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::kivsee::proto::render::v1::EffectConfig&>(::kivsee::proto::render::v1::_EffectConfig_default_instance_);
}
inline const ::kivsee::proto::render::v1::EffectConfig& EffectProto::effect_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kivsee.proto.render.v1.EffectProto.effect_config)
  return _internal_effect_config();
}
inline void EffectProto::unsafe_arena_set_allocated_effect_config(
    ::kivsee::proto::render::v1::EffectConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.effect_config_);
  }
  _impl_.effect_config_ = reinterpret_cast<::kivsee::proto::render::v1::EffectConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kivsee.proto.render.v1.EffectProto.effect_config)
}
inline ::kivsee::proto::render::v1::EffectConfig* PROTOBUF_NULLABLE EffectProto::release_effect_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kivsee::proto::render::v1::EffectConfig* released = _impl_.effect_config_;
  _impl_.effect_config_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kivsee::proto::render::v1::EffectConfig* PROTOBUF_NULLABLE EffectProto::unsafe_arena_release_effect_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kivsee.proto.render.v1.EffectProto.effect_config)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kivsee::proto::render::v1::EffectConfig* temp = _impl_.effect_config_;
  _impl_.effect_config_ = nullptr;
  return temp;
}
inline ::kivsee::proto::render::v1::EffectConfig* PROTOBUF_NONNULL EffectProto::_internal_mutable_effect_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.effect_config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kivsee::proto::render::v1::EffectConfig>(GetArena());
    _impl_.effect_config_ = reinterpret_cast<::kivsee::proto::render::v1::EffectConfig*>(p);
  }
  return _impl_.effect_config_;
}
inline ::kivsee::proto::render::v1::EffectConfig* PROTOBUF_NONNULL EffectProto::mutable_effect_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kivsee::proto::render::v1::EffectConfig* _msg = _internal_mutable_effect_config();
  // @@protoc_insertion_point(field_mutable:kivsee.proto.render.v1.EffectProto.effect_config)
  return _msg;
}
inline void EffectProto::set_allocated_effect_config(::kivsee::proto::render::v1::EffectConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.effect_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.effect_config_ = reinterpret_cast<::kivsee::proto::render::v1::EffectConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:kivsee.proto.render.v1.EffectProto.effect_config)
}

// .kivsee.proto.render.v1.ConstColorEffectConfig const_color = 2 [json_name = "constColor"];
inline bool EffectProto::has_const_color() const {
  return effect_case() == kConstColor;
}
inline bool EffectProto::_internal_has_const_color() const {
  return effect_case() == kConstColor;
}
inline void EffectProto::set_has_const_color() {
  _impl_._oneof_case_[0] = kConstColor;
}
inline void EffectProto::clear_const_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (effect_case() == kConstColor) {
    if (GetArena() == nullptr) {
      delete _impl_.effect_.const_color_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.effect_.const_color_);
    }
    clear_has_effect();
  }
}
inline ::kivsee::proto::render::v1::ConstColorEffectConfig* PROTOBUF_NULLABLE EffectProto::release_const_color() {
  // @@protoc_insertion_point(field_release:kivsee.proto.render.v1.EffectProto.const_color)
  if (effect_case() == kConstColor) {
    clear_has_effect();
    auto* temp = reinterpret_cast<::kivsee::proto::render::v1::ConstColorEffectConfig*>(_impl_.effect_.const_color_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.effect_.const_color_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kivsee::proto::render::v1::ConstColorEffectConfig& EffectProto::_internal_const_color() const {
  return effect_case() == kConstColor ? *reinterpret_cast<::kivsee::proto::render::v1::ConstColorEffectConfig*>(_impl_.effect_.const_color_) : reinterpret_cast<::kivsee::proto::render::v1::ConstColorEffectConfig&>(::kivsee::proto::render::v1::_ConstColorEffectConfig_default_instance_);
}
inline const ::kivsee::proto::render::v1::ConstColorEffectConfig& EffectProto::const_color() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kivsee.proto.render.v1.EffectProto.const_color)
  return _internal_const_color();
}
inline ::kivsee::proto::render::v1::ConstColorEffectConfig* PROTOBUF_NULLABLE EffectProto::unsafe_arena_release_const_color() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kivsee.proto.render.v1.EffectProto.const_color)
  if (effect_case() == kConstColor) {
    clear_has_effect();
    auto* temp = reinterpret_cast<::kivsee::proto::render::v1::ConstColorEffectConfig*>(_impl_.effect_.const_color_);
    _impl_.effect_.const_color_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EffectProto::unsafe_arena_set_allocated_const_color(
    ::kivsee::proto::render::v1::ConstColorEffectConfig* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_effect();
  if (value) {
    set_has_const_color();
    _impl_.effect_.const_color_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kivsee.proto.render.v1.EffectProto.const_color)
}
inline ::kivsee::proto::render::v1::ConstColorEffectConfig* PROTOBUF_NONNULL EffectProto::_internal_mutable_const_color() {
  if (effect_case() != kConstColor) {
    clear_effect();
    set_has_const_color();
    _impl_.effect_.const_color_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::kivsee::proto::render::v1::ConstColorEffectConfig>(GetArena()));
  }
  return reinterpret_cast<::kivsee::proto::render::v1::ConstColorEffectConfig*>(_impl_.effect_.const_color_);
}
inline ::kivsee::proto::render::v1::ConstColorEffectConfig* PROTOBUF_NONNULL EffectProto::mutable_const_color()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kivsee::proto::render::v1::ConstColorEffectConfig* _msg = _internal_mutable_const_color();
  // @@protoc_insertion_point(field_mutable:kivsee.proto.render.v1.EffectProto.const_color)
  return _msg;
}

// .kivsee.proto.render.v1.RainbowEffectConfig rainbow = 3 [json_name = "rainbow"];
inline bool EffectProto::has_rainbow() const {
  return effect_case() == kRainbow;
}
inline bool EffectProto::_internal_has_rainbow() const {
  return effect_case() == kRainbow;
}
inline void EffectProto::set_has_rainbow() {
  _impl_._oneof_case_[0] = kRainbow;
}
inline void EffectProto::clear_rainbow() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (effect_case() == kRainbow) {
    if (GetArena() == nullptr) {
      delete _impl_.effect_.rainbow_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.effect_.rainbow_);
    }
    clear_has_effect();
  }
}
inline ::kivsee::proto::render::v1::RainbowEffectConfig* PROTOBUF_NULLABLE EffectProto::release_rainbow() {
  // @@protoc_insertion_point(field_release:kivsee.proto.render.v1.EffectProto.rainbow)
  if (effect_case() == kRainbow) {
    clear_has_effect();
    auto* temp = reinterpret_cast<::kivsee::proto::render::v1::RainbowEffectConfig*>(_impl_.effect_.rainbow_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.effect_.rainbow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kivsee::proto::render::v1::RainbowEffectConfig& EffectProto::_internal_rainbow() const {
  return effect_case() == kRainbow ? *reinterpret_cast<::kivsee::proto::render::v1::RainbowEffectConfig*>(_impl_.effect_.rainbow_) : reinterpret_cast<::kivsee::proto::render::v1::RainbowEffectConfig&>(::kivsee::proto::render::v1::_RainbowEffectConfig_default_instance_);
}
inline const ::kivsee::proto::render::v1::RainbowEffectConfig& EffectProto::rainbow() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kivsee.proto.render.v1.EffectProto.rainbow)
  return _internal_rainbow();
}
inline ::kivsee::proto::render::v1::RainbowEffectConfig* PROTOBUF_NULLABLE EffectProto::unsafe_arena_release_rainbow() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kivsee.proto.render.v1.EffectProto.rainbow)
  if (effect_case() == kRainbow) {
    clear_has_effect();
    auto* temp = reinterpret_cast<::kivsee::proto::render::v1::RainbowEffectConfig*>(_impl_.effect_.rainbow_);
    _impl_.effect_.rainbow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EffectProto::unsafe_arena_set_allocated_rainbow(
    ::kivsee::proto::render::v1::RainbowEffectConfig* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_effect();
  if (value) {
    set_has_rainbow();
    _impl_.effect_.rainbow_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kivsee.proto.render.v1.EffectProto.rainbow)
}
inline ::kivsee::proto::render::v1::RainbowEffectConfig* PROTOBUF_NONNULL EffectProto::_internal_mutable_rainbow() {
  if (effect_case() != kRainbow) {
    clear_effect();
    set_has_rainbow();
    _impl_.effect_.rainbow_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::kivsee::proto::render::v1::RainbowEffectConfig>(GetArena()));
  }
  return reinterpret_cast<::kivsee::proto::render::v1::RainbowEffectConfig*>(_impl_.effect_.rainbow_);
}
inline ::kivsee::proto::render::v1::RainbowEffectConfig* PROTOBUF_NONNULL EffectProto::mutable_rainbow()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kivsee::proto::render::v1::RainbowEffectConfig* _msg = _internal_mutable_rainbow();
  // @@protoc_insertion_point(field_mutable:kivsee.proto.render.v1.EffectProto.rainbow)
  return _msg;
}

// .kivsee.proto.render.v1.BrightnessEffectConfig brightness = 4 [json_name = "brightness"];
inline bool EffectProto::has_brightness() const {
  return effect_case() == kBrightness;
}
inline bool EffectProto::_internal_has_brightness() const {
  return effect_case() == kBrightness;
}
inline void EffectProto::set_has_brightness() {
  _impl_._oneof_case_[0] = kBrightness;
}
inline void EffectProto::clear_brightness() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (effect_case() == kBrightness) {
    if (GetArena() == nullptr) {
      delete _impl_.effect_.brightness_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.effect_.brightness_);
    }
    clear_has_effect();
  }
}
inline ::kivsee::proto::render::v1::BrightnessEffectConfig* PROTOBUF_NULLABLE EffectProto::release_brightness() {
  // @@protoc_insertion_point(field_release:kivsee.proto.render.v1.EffectProto.brightness)
  if (effect_case() == kBrightness) {
    clear_has_effect();
    auto* temp = reinterpret_cast<::kivsee::proto::render::v1::BrightnessEffectConfig*>(_impl_.effect_.brightness_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.effect_.brightness_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kivsee::proto::render::v1::BrightnessEffectConfig& EffectProto::_internal_brightness() const {
  return effect_case() == kBrightness ? *reinterpret_cast<::kivsee::proto::render::v1::BrightnessEffectConfig*>(_impl_.effect_.brightness_) : reinterpret_cast<::kivsee::proto::render::v1::BrightnessEffectConfig&>(::kivsee::proto::render::v1::_BrightnessEffectConfig_default_instance_);
}
inline const ::kivsee::proto::render::v1::BrightnessEffectConfig& EffectProto::brightness() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kivsee.proto.render.v1.EffectProto.brightness)
  return _internal_brightness();
}
inline ::kivsee::proto::render::v1::BrightnessEffectConfig* PROTOBUF_NULLABLE EffectProto::unsafe_arena_release_brightness() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kivsee.proto.render.v1.EffectProto.brightness)
  if (effect_case() == kBrightness) {
    clear_has_effect();
    auto* temp = reinterpret_cast<::kivsee::proto::render::v1::BrightnessEffectConfig*>(_impl_.effect_.brightness_);
    _impl_.effect_.brightness_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EffectProto::unsafe_arena_set_allocated_brightness(
    ::kivsee::proto::render::v1::BrightnessEffectConfig* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_effect();
  if (value) {
    set_has_brightness();
    _impl_.effect_.brightness_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kivsee.proto.render.v1.EffectProto.brightness)
}
inline ::kivsee::proto::render::v1::BrightnessEffectConfig* PROTOBUF_NONNULL EffectProto::_internal_mutable_brightness() {
  if (effect_case() != kBrightness) {
    clear_effect();
    set_has_brightness();
    _impl_.effect_.brightness_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::kivsee::proto::render::v1::BrightnessEffectConfig>(GetArena()));
  }
  return reinterpret_cast<::kivsee::proto::render::v1::BrightnessEffectConfig*>(_impl_.effect_.brightness_);
}
inline ::kivsee::proto::render::v1::BrightnessEffectConfig* PROTOBUF_NONNULL EffectProto::mutable_brightness()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kivsee::proto::render::v1::BrightnessEffectConfig* _msg = _internal_mutable_brightness();
  // @@protoc_insertion_point(field_mutable:kivsee.proto.render.v1.EffectProto.brightness)
  return _msg;
}

// .kivsee.proto.render.v1.HueEffectConfig hue = 5 [json_name = "hue"];
inline bool EffectProto::has_hue() const {
  return effect_case() == kHue;
}
inline bool EffectProto::_internal_has_hue() const {
  return effect_case() == kHue;
}
inline void EffectProto::set_has_hue() {
  _impl_._oneof_case_[0] = kHue;
}
inline void EffectProto::clear_hue() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (effect_case() == kHue) {
    if (GetArena() == nullptr) {
      delete _impl_.effect_.hue_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.effect_.hue_);
    }
    clear_has_effect();
  }
}
inline ::kivsee::proto::render::v1::HueEffectConfig* PROTOBUF_NULLABLE EffectProto::release_hue() {
  // @@protoc_insertion_point(field_release:kivsee.proto.render.v1.EffectProto.hue)
  if (effect_case() == kHue) {
    clear_has_effect();
    auto* temp = reinterpret_cast<::kivsee::proto::render::v1::HueEffectConfig*>(_impl_.effect_.hue_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.effect_.hue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kivsee::proto::render::v1::HueEffectConfig& EffectProto::_internal_hue() const {
  return effect_case() == kHue ? *reinterpret_cast<::kivsee::proto::render::v1::HueEffectConfig*>(_impl_.effect_.hue_) : reinterpret_cast<::kivsee::proto::render::v1::HueEffectConfig&>(::kivsee::proto::render::v1::_HueEffectConfig_default_instance_);
}
inline const ::kivsee::proto::render::v1::HueEffectConfig& EffectProto::hue() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kivsee.proto.render.v1.EffectProto.hue)
  return _internal_hue();
}
inline ::kivsee::proto::render::v1::HueEffectConfig* PROTOBUF_NULLABLE EffectProto::unsafe_arena_release_hue() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kivsee.proto.render.v1.EffectProto.hue)
  if (effect_case() == kHue) {
    clear_has_effect();
    auto* temp = reinterpret_cast<::kivsee::proto::render::v1::HueEffectConfig*>(_impl_.effect_.hue_);
    _impl_.effect_.hue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EffectProto::unsafe_arena_set_allocated_hue(
    ::kivsee::proto::render::v1::HueEffectConfig* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_effect();
  if (value) {
    set_has_hue();
    _impl_.effect_.hue_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kivsee.proto.render.v1.EffectProto.hue)
}
inline ::kivsee::proto::render::v1::HueEffectConfig* PROTOBUF_NONNULL EffectProto::_internal_mutable_hue() {
  if (effect_case() != kHue) {
    clear_effect();
    set_has_hue();
    _impl_.effect_.hue_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::kivsee::proto::render::v1::HueEffectConfig>(GetArena()));
  }
  return reinterpret_cast<::kivsee::proto::render::v1::HueEffectConfig*>(_impl_.effect_.hue_);
}
inline ::kivsee::proto::render::v1::HueEffectConfig* PROTOBUF_NONNULL EffectProto::mutable_hue()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kivsee::proto::render::v1::HueEffectConfig* _msg = _internal_mutable_hue();
  // @@protoc_insertion_point(field_mutable:kivsee.proto.render.v1.EffectProto.hue)
  return _msg;
}

// .kivsee.proto.render.v1.SaturationEffectConfig saturation = 6 [json_name = "saturation"];
inline bool EffectProto::has_saturation() const {
  return effect_case() == kSaturation;
}
inline bool EffectProto::_internal_has_saturation() const {
  return effect_case() == kSaturation;
}
inline void EffectProto::set_has_saturation() {
  _impl_._oneof_case_[0] = kSaturation;
}
inline void EffectProto::clear_saturation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (effect_case() == kSaturation) {
    if (GetArena() == nullptr) {
      delete _impl_.effect_.saturation_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.effect_.saturation_);
    }
    clear_has_effect();
  }
}
inline ::kivsee::proto::render::v1::SaturationEffectConfig* PROTOBUF_NULLABLE EffectProto::release_saturation() {
  // @@protoc_insertion_point(field_release:kivsee.proto.render.v1.EffectProto.saturation)
  if (effect_case() == kSaturation) {
    clear_has_effect();
    auto* temp = reinterpret_cast<::kivsee::proto::render::v1::SaturationEffectConfig*>(_impl_.effect_.saturation_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.effect_.saturation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kivsee::proto::render::v1::SaturationEffectConfig& EffectProto::_internal_saturation() const {
  return effect_case() == kSaturation ? *reinterpret_cast<::kivsee::proto::render::v1::SaturationEffectConfig*>(_impl_.effect_.saturation_) : reinterpret_cast<::kivsee::proto::render::v1::SaturationEffectConfig&>(::kivsee::proto::render::v1::_SaturationEffectConfig_default_instance_);
}
inline const ::kivsee::proto::render::v1::SaturationEffectConfig& EffectProto::saturation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kivsee.proto.render.v1.EffectProto.saturation)
  return _internal_saturation();
}
inline ::kivsee::proto::render::v1::SaturationEffectConfig* PROTOBUF_NULLABLE EffectProto::unsafe_arena_release_saturation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kivsee.proto.render.v1.EffectProto.saturation)
  if (effect_case() == kSaturation) {
    clear_has_effect();
    auto* temp = reinterpret_cast<::kivsee::proto::render::v1::SaturationEffectConfig*>(_impl_.effect_.saturation_);
    _impl_.effect_.saturation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EffectProto::unsafe_arena_set_allocated_saturation(
    ::kivsee::proto::render::v1::SaturationEffectConfig* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_effect();
  if (value) {
    set_has_saturation();
    _impl_.effect_.saturation_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kivsee.proto.render.v1.EffectProto.saturation)
}
inline ::kivsee::proto::render::v1::SaturationEffectConfig* PROTOBUF_NONNULL EffectProto::_internal_mutable_saturation() {
  if (effect_case() != kSaturation) {
    clear_effect();
    set_has_saturation();
    _impl_.effect_.saturation_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::kivsee::proto::render::v1::SaturationEffectConfig>(GetArena()));
  }
  return reinterpret_cast<::kivsee::proto::render::v1::SaturationEffectConfig*>(_impl_.effect_.saturation_);
}
inline ::kivsee::proto::render::v1::SaturationEffectConfig* PROTOBUF_NONNULL EffectProto::mutable_saturation()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kivsee::proto::render::v1::SaturationEffectConfig* _msg = _internal_mutable_saturation();
  // @@protoc_insertion_point(field_mutable:kivsee.proto.render.v1.EffectProto.saturation)
  return _msg;
}

// .kivsee.proto.render.v1.SnakeEffectConfig snake = 7 [json_name = "snake"];
inline bool EffectProto::has_snake() const {
  return effect_case() == kSnake;
}
inline bool EffectProto::_internal_has_snake() const {
  return effect_case() == kSnake;
}
inline void EffectProto::set_has_snake() {
  _impl_._oneof_case_[0] = kSnake;
}
inline void EffectProto::clear_snake() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (effect_case() == kSnake) {
    if (GetArena() == nullptr) {
      delete _impl_.effect_.snake_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.effect_.snake_);
    }
    clear_has_effect();
  }
}
inline ::kivsee::proto::render::v1::SnakeEffectConfig* PROTOBUF_NULLABLE EffectProto::release_snake() {
  // @@protoc_insertion_point(field_release:kivsee.proto.render.v1.EffectProto.snake)
  if (effect_case() == kSnake) {
    clear_has_effect();
    auto* temp = reinterpret_cast<::kivsee::proto::render::v1::SnakeEffectConfig*>(_impl_.effect_.snake_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.effect_.snake_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kivsee::proto::render::v1::SnakeEffectConfig& EffectProto::_internal_snake() const {
  return effect_case() == kSnake ? *reinterpret_cast<::kivsee::proto::render::v1::SnakeEffectConfig*>(_impl_.effect_.snake_) : reinterpret_cast<::kivsee::proto::render::v1::SnakeEffectConfig&>(::kivsee::proto::render::v1::_SnakeEffectConfig_default_instance_);
}
inline const ::kivsee::proto::render::v1::SnakeEffectConfig& EffectProto::snake() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kivsee.proto.render.v1.EffectProto.snake)
  return _internal_snake();
}
inline ::kivsee::proto::render::v1::SnakeEffectConfig* PROTOBUF_NULLABLE EffectProto::unsafe_arena_release_snake() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kivsee.proto.render.v1.EffectProto.snake)
  if (effect_case() == kSnake) {
    clear_has_effect();
    auto* temp = reinterpret_cast<::kivsee::proto::render::v1::SnakeEffectConfig*>(_impl_.effect_.snake_);
    _impl_.effect_.snake_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EffectProto::unsafe_arena_set_allocated_snake(
    ::kivsee::proto::render::v1::SnakeEffectConfig* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_effect();
  if (value) {
    set_has_snake();
    _impl_.effect_.snake_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kivsee.proto.render.v1.EffectProto.snake)
}
inline ::kivsee::proto::render::v1::SnakeEffectConfig* PROTOBUF_NONNULL EffectProto::_internal_mutable_snake() {
  if (effect_case() != kSnake) {
    clear_effect();
    set_has_snake();
    _impl_.effect_.snake_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::kivsee::proto::render::v1::SnakeEffectConfig>(GetArena()));
  }
  return reinterpret_cast<::kivsee::proto::render::v1::SnakeEffectConfig*>(_impl_.effect_.snake_);
}
inline ::kivsee::proto::render::v1::SnakeEffectConfig* PROTOBUF_NONNULL EffectProto::mutable_snake()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kivsee::proto::render::v1::SnakeEffectConfig* _msg = _internal_mutable_snake();
  // @@protoc_insertion_point(field_mutable:kivsee.proto.render.v1.EffectProto.snake)
  return _msg;
}

inline bool EffectProto::has_effect() const {
  return effect_case() != EFFECT_NOT_SET;
}
inline void EffectProto::clear_has_effect() {
  _impl_._oneof_case_[0] = EFFECT_NOT_SET;
}
inline EffectProto::EffectCase EffectProto::effect_case() const {
  return EffectProto::EffectCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AnimationProto

// repeated .kivsee.proto.render.v1.EffectProto effects = 1 [json_name = "effects"];
inline int AnimationProto::_internal_effects_size() const {
  return _internal_effects().size();
}
inline int AnimationProto::effects_size() const {
  return _internal_effects_size();
}
inline void AnimationProto::clear_effects() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.effects_.Clear();
}
inline ::kivsee::proto::render::v1::EffectProto* PROTOBUF_NONNULL AnimationProto::mutable_effects(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kivsee.proto.render.v1.AnimationProto.effects)
  return _internal_mutable_effects()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kivsee::proto::render::v1::EffectProto>* PROTOBUF_NONNULL AnimationProto::mutable_effects()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kivsee.proto.render.v1.AnimationProto.effects)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_effects();
}
inline const ::kivsee::proto::render::v1::EffectProto& AnimationProto::effects(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kivsee.proto.render.v1.AnimationProto.effects)
  return _internal_effects().Get(index);
}
inline ::kivsee::proto::render::v1::EffectProto* PROTOBUF_NONNULL AnimationProto::add_effects()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kivsee::proto::render::v1::EffectProto* _add = _internal_mutable_effects()->Add();
  // @@protoc_insertion_point(field_add:kivsee.proto.render.v1.AnimationProto.effects)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kivsee::proto::render::v1::EffectProto>& AnimationProto::effects() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kivsee.proto.render.v1.AnimationProto.effects)
  return _internal_effects();
}
inline const ::google::protobuf::RepeatedPtrField<::kivsee::proto::render::v1::EffectProto>&
AnimationProto::_internal_effects() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.effects_;
}
inline ::google::protobuf::RepeatedPtrField<::kivsee::proto::render::v1::EffectProto>* PROTOBUF_NONNULL
AnimationProto::_internal_mutable_effects() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.effects_;
}

// uint32 duration_ms = 2 [json_name = "durationMs"];
inline void AnimationProto::clear_duration_ms() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.duration_ms_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t AnimationProto::duration_ms() const {
  // @@protoc_insertion_point(field_get:kivsee.proto.render.v1.AnimationProto.duration_ms)
  return _internal_duration_ms();
}
inline void AnimationProto::set_duration_ms(::uint32_t value) {
  _internal_set_duration_ms(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:kivsee.proto.render.v1.AnimationProto.duration_ms)
}
inline ::uint32_t AnimationProto::_internal_duration_ms() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.duration_ms_;
}
inline void AnimationProto::_internal_set_duration_ms(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.duration_ms_ = value;
}

// uint32 num_repeats = 3 [json_name = "numRepeats"];
inline void AnimationProto::clear_num_repeats() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_repeats_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t AnimationProto::num_repeats() const {
  // @@protoc_insertion_point(field_get:kivsee.proto.render.v1.AnimationProto.num_repeats)
  return _internal_num_repeats();
}
inline void AnimationProto::set_num_repeats(::uint32_t value) {
  _internal_set_num_repeats(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:kivsee.proto.render.v1.AnimationProto.num_repeats)
}
inline ::uint32_t AnimationProto::_internal_num_repeats() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.num_repeats_;
}
inline void AnimationProto::_internal_set_num_repeats(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_repeats_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace render
}  // namespace proto
}  // namespace kivsee


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // kivsee_2fproto_2frender_2fv1_2feffects_2eproto_2epb_2eh
